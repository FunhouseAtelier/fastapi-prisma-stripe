# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class AssociateActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.AssociateCreateInput,
        include: Optional[types.AssociateInclude] = None
    ) -> _PrismaModelT:
        """Create a new Associate record.

        Parameters
        ----------
        data
            Associate record data
        include
            Specifies which relations should be loaded on the returned Associate model

        Returns
        -------
        prisma.models.Associate
            The created Associate record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Associate record from just the required fields
        associate = await Associate.prisma().create(
            data={
                # data to create a Associate record
                'name': 'bbadfchfja',
                'street_address_1': 'dhheabfhf',
                'city': 'ggciceaie',
                'state': 'bbehjachib',
                'zip_code': 'cadfabfehe',
                'phone': 'dgiiaaijj',
                'email': 'bfaiacjjfc',
                'username': 'eigcfgbif',
                'salt': 'bagcfbhiig',
                'w9_updated_at': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AssociateCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Associate records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Associate record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Associate.prisma().create_many(
            data=[
                {
                    # data to create a Associate record
                    'name': 'cghideieh',
                    'street_address_1': 'biabhbdai',
                    'city': 'idghgaicb',
                    'state': 'fjfddhigg',
                    'zip_code': 'hjaecfifb',
                    'phone': 'cbbbjbfcii',
                    'email': 'bbejhfidcb',
                    'username': 'bgeecijdgg',
                    'salt': 'bdiicjafbj',
                    'w9_updated_at': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Associate record
                    'name': 'bgehebiafc',
                    'street_address_1': 'bghffegacj',
                    'city': 'bhghchehcc',
                    'state': 'dcgchcbbf',
                    'zip_code': 'bdedcabahc',
                    'phone': 'ghfhiafcb',
                    'email': 'heejgedji',
                    'username': 'bjgjgibgbf',
                    'salt': 'bbbgbhfjge',
                    'w9_updated_at': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AssociateWhereUniqueInput,
        include: Optional[types.AssociateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Associate record.

        Parameters
        ----------
        where
            Associate filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Associate model

        Returns
        -------
        prisma.models.Associate
            The deleted Associate record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        associate = await Associate.prisma().delete(
            where={
                'id': 'igbehcbab',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AssociateWhereUniqueInput,
        include: Optional[types.AssociateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Associate record.

        Parameters
        ----------
        where
            Associate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Associate model

        Returns
        -------
        prisma.models.Associate
            The found Associate record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        associate = await Associate.prisma().find_unique(
            where={
                'id': 'bdadaadhag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AssociateWhereUniqueInput,
        include: Optional[types.AssociateInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Associate record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Associate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Associate model

        Returns
        -------
        prisma.models.Associate
            The found Associate record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        associate = await Associate.prisma().find_unique_or_raise(
            where={
                'id': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssociateWhereInput] = None,
        cursor: Optional[types.AssociateWhereUniqueInput] = None,
        include: Optional[types.AssociateInclude] = None,
        order: Optional[Union[types.AssociateOrderByInput, List[types.AssociateOrderByInput]]] = None,
        distinct: Optional[List[types.AssociateScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Associate records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Associate records returned
        skip
            Ignore the first N results
        where
            Associate filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Associate model
        order
            Order the returned Associate records by any field
        distinct
            Filter Associate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Associate]
            The list of all Associate records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Associate records
        associates = await Associate.prisma().find_many(take=10)

        # find the first 5 Associate records ordered by the id field
        associates = await Associate.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssociateWhereInput] = None,
        cursor: Optional[types.AssociateWhereUniqueInput] = None,
        include: Optional[types.AssociateInclude] = None,
        order: Optional[Union[types.AssociateOrderByInput, List[types.AssociateOrderByInput]]] = None,
        distinct: Optional[List[types.AssociateScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Associate record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Associate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Associate model
        order
            Order the returned Associate records by any field
        distinct
            Filter Associate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Associate
            The first Associate record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Associate record ordered by the created_at field
        associate = await Associate.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AssociateWhereInput] = None,
        cursor: Optional[types.AssociateWhereUniqueInput] = None,
        include: Optional[types.AssociateInclude] = None,
        order: Optional[Union[types.AssociateOrderByInput, List[types.AssociateOrderByInput]]] = None,
        distinct: Optional[List[types.AssociateScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Associate record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Associate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Associate model
        order
            Order the returned Associate records by any field
        distinct
            Filter Associate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Associate
            The first Associate record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Associate record ordered by the updated_at field
        associate = await Associate.prisma().find_first_or_raise(
            skip=1,
            order={
                'updated_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AssociateUpdateInput,
        where: types.AssociateWhereUniqueInput,
        include: Optional[types.AssociateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Associate record.

        Parameters
        ----------
        data
            Associate record data specifying what to update
        where
            Associate filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Associate model

        Returns
        -------
        prisma.models.Associate
            The updated Associate record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        associate = await Associate.prisma().update(
            where={
                'id': 'caaaedabfc',
            },
            data={
                # data to update the Associate record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AssociateWhereUniqueInput,
        data: types.AssociateUpsertInput,
        include: Optional[types.AssociateInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Associate filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Associate model

        Returns
        -------
        prisma.models.Associate
            The created or updated Associate record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        associate = await Associate.prisma().upsert(
            where={
                'id': 'bigibebcib',
            },
            data={
                'create': {
                    'id': 'bigibebcib',
                    'name': 'bgehebiafc',
                    'street_address_1': 'bghffegacj',
                    'city': 'bhghchehcc',
                    'state': 'dcgchcbbf',
                    'zip_code': 'bdedcabahc',
                    'phone': 'ghfhiafcb',
                    'email': 'heejgedji',
                    'username': 'bjgjgibgbf',
                    'salt': 'bbbgbhfjge',
                    'w9_updated_at': datetime.datetime.utcnow(),
                },
                'update': {
                    'name': 'bgehebiafc',
                    'street_address_1': 'bghffegacj',
                    'city': 'bhghchehcc',
                    'state': 'dcgchcbbf',
                    'zip_code': 'bdedcabahc',
                    'phone': 'ghfhiafcb',
                    'email': 'heejgedji',
                    'username': 'bjgjgibgbf',
                    'salt': 'bbbgbhfjge',
                    'w9_updated_at': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AssociateUpdateManyMutationInput,
        where: types.AssociateWhereInput,
    ) -> int:
        """Update multiple Associate records

        Parameters
        ----------
        data
            Associate data to update the selected Associate records to
        where
            Filter to select the Associate records to update

        Returns
        -------
        int
            The total number of Associate records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Associate records
        total = await Associate.prisma().update_many(
            data={
                'name': 'bigaiehgcc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssociateWhereInput] = None,
        cursor: Optional[types.AssociateWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Associate records present in the database

        Parameters
        ----------
        select
            Select the Associate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Associate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssociateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Associate.prisma().count()

        # results: prisma.types.AssociateCountAggregateOutput
        results = await Associate.prisma().count(
            select={
                '_all': True,
                'business_name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AssociateCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssociateWhereInput] = None,
        cursor: Optional[types.AssociateWhereUniqueInput] = None,
    ) -> types.AssociateCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AssociateCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AssociateWhereInput] = None,
        cursor: Optional[types.AssociateWhereUniqueInput] = None,
    ) -> Union[int, types.AssociateCountAggregateOutput]:
        """Count the number of Associate records present in the database

        Parameters
        ----------
        select
            Select the Associate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Associate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AssociateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Associate.prisma().count()

        # results: prisma.types.AssociateCountAggregateOutput
        results = await Associate.prisma().count(
            select={
                '_all': True,
                'street_address_1': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AssociateCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AssociateWhereInput] = None
    ) -> int:
        """Delete multiple Associate records.

        Parameters
        ----------
        where
            Optional Associate filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Associate records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Associate records
        total = await Associate.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AssociateScalarFieldKeys'],
        *,
        where: Optional['types.AssociateWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AssociateAvgAggregateInput'] = None,
        sum: Optional['types.AssociateSumAggregateInput'] = None,
        min: Optional['types.AssociateMinAggregateInput'] = None,
        max: Optional['types.AssociateMaxAggregateInput'] = None,
        having: Optional['types.AssociateScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AssociateCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AssociateScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AssociateScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AssociateGroupByOutput']:
        """Group Associate records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Associate fields to group records by
        where
            Associate filter to select records
        take
            Limit the maximum number of Associate records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AssociateGroupByOutput]
            A list of dictionaries representing the Associate record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Associate records by street_address_2 values
        # and count how many records are in each group
        results = await Associate.prisma().group_by(
            ['street_address_2'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ClientActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.ClientCreateInput,
        include: Optional[types.ClientInclude] = None
    ) -> _PrismaModelT:
        """Create a new Client record.

        Parameters
        ----------
        data
            Client record data
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The created Client record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Client record from just the required fields
        client = await Client.prisma().create(
            data={
                # data to create a Client record
                'account_number': 'beeifcbebf',
                'contact_name': 'bgcigfahea',
                'email': 'bcejgaggif',
                'phone': 'idfjadbcc',
                'street_address_1': 'hgdhbjhhj',
                'city': 'ecjjjfbae',
                'state': 'bhhfibbigf',
                'zip_code': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ClientCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Client records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Client record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Client.prisma().create_many(
            data=[
                {
                    # data to create a Client record
                    'account_number': 'jjfeafhfj',
                    'contact_name': 'cbachdgfce',
                    'email': 'chbfcacbd',
                    'phone': 'efggddide',
                    'street_address_1': 'caficfigfb',
                    'city': 'bfidgijfjc',
                    'state': 'ihieecagf',
                    'zip_code': 'bghfciaafe',
                },
                {
                    # data to create a Client record
                    'account_number': 'bgchfhgceh',
                    'contact_name': 'cafeiaccbc',
                    'email': 'gaddfhfh',
                    'phone': 'gieegcbeg',
                    'street_address_1': 'bgcffadich',
                    'city': 'fcbichhci',
                    'state': 'bcggadccgf',
                    'zip_code': 'jdcfdcgc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ClientWhereUniqueInput,
        include: Optional[types.ClientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Client record.

        Parameters
        ----------
        where
            Client filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The deleted Client record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        client = await Client.prisma().delete(
            where={
                'id': 'cafdaehjid',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ClientWhereUniqueInput,
        include: Optional[types.ClientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Client record.

        Parameters
        ----------
        where
            Client filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The found Client record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        client = await Client.prisma().find_unique(
            where={
                'id': 'gifdddbia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ClientWhereUniqueInput,
        include: Optional[types.ClientInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Client record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Client filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The found Client record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        client = await Client.prisma().find_unique_or_raise(
            where={
                'id': 'bchehecef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
        include: Optional[types.ClientInclude] = None,
        order: Optional[Union[types.ClientOrderByInput, List[types.ClientOrderByInput]]] = None,
        distinct: Optional[List[types.ClientScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Client records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Client records returned
        skip
            Ignore the first N results
        where
            Client filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Client model
        order
            Order the returned Client records by any field
        distinct
            Filter Client records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Client]
            The list of all Client records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Client records
        clients = await Client.prisma().find_many(take=10)

        # find the first 5 Client records ordered by the id field
        clients = await Client.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
        include: Optional[types.ClientInclude] = None,
        order: Optional[Union[types.ClientOrderByInput, List[types.ClientOrderByInput]]] = None,
        distinct: Optional[List[types.ClientScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Client record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Client filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Client model
        order
            Order the returned Client records by any field
        distinct
            Filter Client records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Client
            The first Client record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Client record ordered by the created_at field
        client = await Client.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
        include: Optional[types.ClientInclude] = None,
        order: Optional[Union[types.ClientOrderByInput, List[types.ClientOrderByInput]]] = None,
        distinct: Optional[List[types.ClientScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Client record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Client filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Client model
        order
            Order the returned Client records by any field
        distinct
            Filter Client records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Client
            The first Client record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Client record ordered by the updated_at field
        client = await Client.prisma().find_first_or_raise(
            skip=1,
            order={
                'updated_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ClientUpdateInput,
        where: types.ClientWhereUniqueInput,
        include: Optional[types.ClientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Client record.

        Parameters
        ----------
        data
            Client record data specifying what to update
        where
            Client filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The updated Client record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        client = await Client.prisma().update(
            where={
                'id': 'jeijcbhfe',
            },
            data={
                # data to update the Client record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ClientWhereUniqueInput,
        data: types.ClientUpsertInput,
        include: Optional[types.ClientInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Client filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The created or updated Client record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        client = await Client.prisma().upsert(
            where={
                'id': 'bjgejjabff',
            },
            data={
                'create': {
                    'id': 'bjgejjabff',
                    'account_number': 'bgchfhgceh',
                    'contact_name': 'cafeiaccbc',
                    'email': 'gaddfhfh',
                    'phone': 'gieegcbeg',
                    'street_address_1': 'bgcffadich',
                    'city': 'fcbichhci',
                    'state': 'bcggadccgf',
                    'zip_code': 'jdcfdcgc',
                },
                'update': {
                    'account_number': 'bgchfhgceh',
                    'contact_name': 'cafeiaccbc',
                    'email': 'gaddfhfh',
                    'phone': 'gieegcbeg',
                    'street_address_1': 'bgcffadich',
                    'city': 'fcbichhci',
                    'state': 'bcggadccgf',
                    'zip_code': 'jdcfdcgc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ClientUpdateManyMutationInput,
        where: types.ClientWhereInput,
    ) -> int:
        """Update multiple Client records

        Parameters
        ----------
        data
            Client data to update the selected Client records to
        where
            Filter to select the Client records to update

        Returns
        -------
        int
            The total number of Client records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Client records
        total = await Client.prisma().update_many(
            data={
                'account_number': 'bcciijbibg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Client records present in the database

        Parameters
        ----------
        select
            Select the Client fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Client filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Client.prisma().count()

        # results: prisma.types.ClientCountAggregateOutput
        results = await Client.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ClientCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
    ) -> types.ClientCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ClientCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
    ) -> Union[int, types.ClientCountAggregateOutput]:
        """Count the number of Client records present in the database

        Parameters
        ----------
        select
            Select the Client fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Client filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Client.prisma().count()

        # results: prisma.types.ClientCountAggregateOutput
        results = await Client.prisma().count(
            select={
                '_all': True,
                'contact_name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ClientCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ClientWhereInput] = None
    ) -> int:
        """Delete multiple Client records.

        Parameters
        ----------
        where
            Optional Client filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Client records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Client records
        total = await Client.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ClientScalarFieldKeys'],
        *,
        where: Optional['types.ClientWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ClientAvgAggregateInput'] = None,
        sum: Optional['types.ClientSumAggregateInput'] = None,
        min: Optional['types.ClientMinAggregateInput'] = None,
        max: Optional['types.ClientMaxAggregateInput'] = None,
        having: Optional['types.ClientScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ClientCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ClientScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ClientScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ClientGroupByOutput']:
        """Group Client records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Client fields to group records by
        where
            Client filter to select records
        take
            Limit the maximum number of Client records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ClientGroupByOutput]
            A list of dictionaries representing the Client record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Client records by email values
        # and count how many records are in each group
        results = await Client.prisma().group_by(
            ['email'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProductActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.ProductCreateInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Create a new Product record.

        Parameters
        ----------
        data
            Product record data
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created Product record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Product record from just the required fields
        product = await Product.prisma().create(
            data={
                # data to create a Product record
                'name': 'cffcachfd',
                'unit': 'bccdfhdigc',
                'unit_price': 541269159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProductCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Product records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Product record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Product.prisma().create_many(
            data=[
                {
                    # data to create a Product record
                    'name': 'bageiegghg',
                    'unit': 'faidicegb',
                    'unit_price': 1024265714,
                },
                {
                    # data to create a Product record
                    'name': 'ihcahiead',
                    'unit': 'biheheiajg',
                    'unit_price': 916896761,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Product record.

        Parameters
        ----------
        where
            Product filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The deleted Product record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().delete(
            where={
                'id': 'hgjcghfbi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Product record.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique(
            where={
                'id': 'icadbcehj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Product record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique_or_raise(
            where={
                'id': 'jchciaee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Product records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N results
        where
            Product filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Product]
            The list of all Product records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Product records
        products = await Product.prisma().find_many(take=10)

        # find the first 5 Product records ordered by the id field
        products = await Product.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Product record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the created_at field
        product = await Product.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Product record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the updated_at field
        product = await Product.prisma().find_first_or_raise(
            skip=1,
            order={
                'updated_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProductUpdateInput,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Product record.

        Parameters
        ----------
        data
            Product record data specifying what to update
        where
            Product filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The updated Product record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        product = await Product.prisma().update(
            where={
                'id': 'deeificjd',
            },
            data={
                # data to update the Product record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProductWhereUniqueInput,
        data: types.ProductUpsertInput,
        include: Optional[types.ProductInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Product filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created or updated Product record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().upsert(
            where={
                'id': 'bbcbhebbda',
            },
            data={
                'create': {
                    'id': 'bbcbhebbda',
                    'name': 'ihcahiead',
                    'unit': 'biheheiajg',
                    'unit_price': 916896761,
                },
                'update': {
                    'name': 'ihcahiead',
                    'unit': 'biheheiajg',
                    'unit_price': 916896761,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProductUpdateManyMutationInput,
        where: types.ProductWhereInput,
    ) -> int:
        """Update multiple Product records

        Parameters
        ----------
        data
            Product data to update the selected Product records to
        where
            Filter to select the Product records to update

        Returns
        -------
        int
            The total number of Product records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Product records
        total = await Product.prisma().update_many(
            data={
                'name': 'bejfijgcfb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProductCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> types.ProductCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProductCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> Union[int, types.ProductCountAggregateOutput]:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'unit': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProductCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProductWhereInput] = None
    ) -> int:
        """Delete multiple Product records.

        Parameters
        ----------
        where
            Optional Product filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Product records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Product records
        total = await Product.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProductScalarFieldKeys'],
        *,
        where: Optional['types.ProductWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProductAvgAggregateInput'] = None,
        sum: Optional['types.ProductSumAggregateInput'] = None,
        min: Optional['types.ProductMinAggregateInput'] = None,
        max: Optional['types.ProductMaxAggregateInput'] = None,
        having: Optional['types.ProductScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProductCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProductScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProductScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProductGroupByOutput']:
        """Group Product records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Product fields to group records by
        where
            Product filter to select records
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProductGroupByOutput]
            A list of dictionaries representing the Product record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Product records by unit_price values
        # and count how many records are in each group
        results = await Product.prisma().group_by(
            ['unit_price'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LineItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.LineItemCreateInput,
        include: Optional[types.LineItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new LineItem record.

        Parameters
        ----------
        data
            LineItem record data
        include
            Specifies which relations should be loaded on the returned LineItem model

        Returns
        -------
        prisma.models.LineItem
            The created LineItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LineItem record from just the required fields
        lineitem = await LineItem.prisma().create(
            data={
                # data to create a LineItem record
                'qty': 208521688,
                'product_id': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LineItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LineItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LineItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LineItem.prisma().create_many(
            data=[
                {
                    # data to create a LineItem record
                    'qty': 1660932118,
                    'product_id': 'fcfhgbjed',
                },
                {
                    # data to create a LineItem record
                    'qty': 736209796,
                    'product_id': 'ejdjahicb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LineItemWhereUniqueInput,
        include: Optional[types.LineItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LineItem record.

        Parameters
        ----------
        where
            LineItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LineItem model

        Returns
        -------
        prisma.models.LineItem
            The deleted LineItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lineitem = await LineItem.prisma().delete(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LineItemWhereUniqueInput,
        include: Optional[types.LineItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LineItem record.

        Parameters
        ----------
        where
            LineItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LineItem model

        Returns
        -------
        prisma.models.LineItem
            The found LineItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lineitem = await LineItem.prisma().find_unique(
            where={
                'id': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LineItemWhereUniqueInput,
        include: Optional[types.LineItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LineItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LineItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LineItem model

        Returns
        -------
        prisma.models.LineItem
            The found LineItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lineitem = await LineItem.prisma().find_unique_or_raise(
            where={
                'id': 'bjafcgbffc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LineItemWhereInput] = None,
        cursor: Optional[types.LineItemWhereUniqueInput] = None,
        include: Optional[types.LineItemInclude] = None,
        order: Optional[Union[types.LineItemOrderByInput, List[types.LineItemOrderByInput]]] = None,
        distinct: Optional[List[types.LineItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LineItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LineItem records returned
        skip
            Ignore the first N results
        where
            LineItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LineItem model
        order
            Order the returned LineItem records by any field
        distinct
            Filter LineItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LineItem]
            The list of all LineItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LineItem records
        lineitems = await LineItem.prisma().find_many(take=10)

        # find the first 5 LineItem records ordered by the id field
        lineitems = await LineItem.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LineItemWhereInput] = None,
        cursor: Optional[types.LineItemWhereUniqueInput] = None,
        include: Optional[types.LineItemInclude] = None,
        order: Optional[Union[types.LineItemOrderByInput, List[types.LineItemOrderByInput]]] = None,
        distinct: Optional[List[types.LineItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LineItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LineItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LineItem model
        order
            Order the returned LineItem records by any field
        distinct
            Filter LineItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LineItem
            The first LineItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LineItem record ordered by the created_at field
        lineitem = await LineItem.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LineItemWhereInput] = None,
        cursor: Optional[types.LineItemWhereUniqueInput] = None,
        include: Optional[types.LineItemInclude] = None,
        order: Optional[Union[types.LineItemOrderByInput, List[types.LineItemOrderByInput]]] = None,
        distinct: Optional[List[types.LineItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LineItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LineItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LineItem model
        order
            Order the returned LineItem records by any field
        distinct
            Filter LineItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LineItem
            The first LineItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LineItem record ordered by the updated_at field
        lineitem = await LineItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'updated_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LineItemUpdateInput,
        where: types.LineItemWhereUniqueInput,
        include: Optional[types.LineItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LineItem record.

        Parameters
        ----------
        data
            LineItem record data specifying what to update
        where
            LineItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LineItem model

        Returns
        -------
        prisma.models.LineItem
            The updated LineItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lineitem = await LineItem.prisma().update(
            where={
                'id': 'hihegjif',
            },
            data={
                # data to update the LineItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LineItemWhereUniqueInput,
        data: types.LineItemUpsertInput,
        include: Optional[types.LineItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LineItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LineItem model

        Returns
        -------
        prisma.models.LineItem
            The created or updated LineItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lineitem = await LineItem.prisma().upsert(
            where={
                'id': 'bdjidcidac',
            },
            data={
                'create': {
                    'id': 'bdjidcidac',
                    'qty': 736209796,
                    'product_id': 'ejdjahicb',
                },
                'update': {
                    'qty': 736209796,
                    'product_id': 'ejdjahicb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LineItemUpdateManyMutationInput,
        where: types.LineItemWhereInput,
    ) -> int:
        """Update multiple LineItem records

        Parameters
        ----------
        data
            LineItem data to update the selected LineItem records to
        where
            Filter to select the LineItem records to update

        Returns
        -------
        int
            The total number of LineItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LineItem records
        total = await LineItem.prisma().update_many(
            data={
                'qty': 856000655
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LineItemWhereInput] = None,
        cursor: Optional[types.LineItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LineItem records present in the database

        Parameters
        ----------
        select
            Select the LineItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LineItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LineItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LineItem.prisma().count()

        # results: prisma.types.LineItemCountAggregateOutput
        results = await LineItem.prisma().count(
            select={
                '_all': True,
                'product_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LineItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LineItemWhereInput] = None,
        cursor: Optional[types.LineItemWhereUniqueInput] = None,
    ) -> types.LineItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LineItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LineItemWhereInput] = None,
        cursor: Optional[types.LineItemWhereUniqueInput] = None,
    ) -> Union[int, types.LineItemCountAggregateOutput]:
        """Count the number of LineItem records present in the database

        Parameters
        ----------
        select
            Select the LineItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LineItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LineItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LineItem.prisma().count()

        # results: prisma.types.LineItemCountAggregateOutput
        results = await LineItem.prisma().count(
            select={
                '_all': True,
                'order_ids': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LineItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LineItemWhereInput] = None
    ) -> int:
        """Delete multiple LineItem records.

        Parameters
        ----------
        where
            Optional LineItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LineItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LineItem records
        total = await LineItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LineItemScalarFieldKeys'],
        *,
        where: Optional['types.LineItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LineItemAvgAggregateInput'] = None,
        sum: Optional['types.LineItemSumAggregateInput'] = None,
        min: Optional['types.LineItemMinAggregateInput'] = None,
        max: Optional['types.LineItemMaxAggregateInput'] = None,
        having: Optional['types.LineItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LineItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LineItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LineItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LineItemGroupByOutput']:
        """Group LineItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LineItem fields to group records by
        where
            LineItem filter to select records
        take
            Limit the maximum number of LineItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LineItemGroupByOutput]
            A list of dictionaries representing the LineItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LineItem records by id values
        # and count how many records are in each group
        results = await LineItem.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrderActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model


    async def create(
        self,
        data: types.OrderCreateInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Create a new Order record.

        Parameters
        ----------
        data
            Order record data
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created Order record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Order record from just the required fields
        order = await Order.prisma().create(
            data={
                # data to create a Order record
                'invoice_number': 'befcddgjce',
                'status': 'bfhdbjjgfd',
                'sales_tax': 2013903098,
                'total_due': 500965035,
                'transaction_fee': 1800624392,
                'revenue': 2077067425,
                'client_id': 'bghcbbcidi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrderCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Order records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Order record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Order.prisma().create_many(
            data=[
                {
                    # data to create a Order record
                    'invoice_number': 'jcgghhgdj',
                    'status': 'beehgcebbg',
                    'sales_tax': 1738083805,
                    'total_due': 340946258,
                    'transaction_fee': 601077795,
                    'revenue': 290603296,
                    'client_id': 'bifficggej',
                },
                {
                    # data to create a Order record
                    'invoice_number': 'bgbbaajbic',
                    'status': 'eegghdhjb',
                    'sales_tax': 300568396,
                    'total_due': 632626069,
                    'transaction_fee': 1724011690,
                    'revenue': 470157467,
                    'client_id': 'bcajcajjbc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Order record.

        Parameters
        ----------
        where
            Order filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The deleted Order record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().delete(
            where={
                'id': 'bfdgheeegf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Order record.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique(
            where={
                'id': 'ececbijji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Order record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique_or_raise(
            where={
                'id': 'cbcfgdcdhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Order records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N results
        where
            Order filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Order]
            The list of all Order records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Order records
        orders = await Order.prisma().find_many(take=10)

        # find the first 5 Order records ordered by the id field
        orders = await Order.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Order record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the created_at field
        order = await Order.prisma().find_first(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Order record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the updated_at field
        order = await Order.prisma().find_first_or_raise(
            skip=1,
            order={
                'updated_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrderUpdateInput,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Order record.

        Parameters
        ----------
        data
            Order record data specifying what to update
        where
            Order filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The updated Order record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        order = await Order.prisma().update(
            where={
                'id': 'fdgjfbhia',
            },
            data={
                # data to update the Order record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrderWhereUniqueInput,
        data: types.OrderUpsertInput,
        include: Optional[types.OrderInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Order filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created or updated Order record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().upsert(
            where={
                'id': 'jcehcdchh',
            },
            data={
                'create': {
                    'id': 'jcehcdchh',
                    'invoice_number': 'bgbbaajbic',
                    'status': 'eegghdhjb',
                    'sales_tax': 300568396,
                    'total_due': 632626069,
                    'transaction_fee': 1724011690,
                    'revenue': 470157467,
                    'client_id': 'bcajcajjbc',
                },
                'update': {
                    'invoice_number': 'bgbbaajbic',
                    'status': 'eegghdhjb',
                    'sales_tax': 300568396,
                    'total_due': 632626069,
                    'transaction_fee': 1724011690,
                    'revenue': 470157467,
                    'client_id': 'bcajcajjbc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrderUpdateManyMutationInput,
        where: types.OrderWhereInput,
    ) -> int:
        """Update multiple Order records

        Parameters
        ----------
        data
            Order data to update the selected Order records to
        where
            Filter to select the Order records to update

        Returns
        -------
        int
            The total number of Order records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Order records
        total = await Order.prisma().update_many(
            data={
                'invoice_number': 'bgcbjdhjcc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrderCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> types.OrderCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrderCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> Union[int, types.OrderCountAggregateOutput]:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'sales_tax': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrderCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrderWhereInput] = None
    ) -> int:
        """Delete multiple Order records.

        Parameters
        ----------
        where
            Optional Order filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Order records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Order records
        total = await Order.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrderScalarFieldKeys'],
        *,
        where: Optional['types.OrderWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrderAvgAggregateInput'] = None,
        sum: Optional['types.OrderSumAggregateInput'] = None,
        min: Optional['types.OrderMinAggregateInput'] = None,
        max: Optional['types.OrderMaxAggregateInput'] = None,
        having: Optional['types.OrderScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrderCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrderScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrderScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrderGroupByOutput']:
        """Group Order records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Order fields to group records by
        where
            Order filter to select records
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrderGroupByOutput]
            A list of dictionaries representing the Order record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Order records by total_due values
        # and count how many records are in each group
        results = await Order.prisma().group_by(
            ['total_due'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models