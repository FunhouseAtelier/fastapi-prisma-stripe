# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
            },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
            },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
            },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
            },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
            },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Associate types

class AssociateOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Associate create method"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    business_name: Optional[_str]
    street_address_2: Optional[_str]
    password: Optional[_str]
    salt_last_revealed_at: Optional[datetime.datetime]
    locked_at: Optional[datetime.datetime]
    ssn: Optional[_str]
    tin: Optional[_str]
    roles: List[_str]
    audited_order_ids: List[_str]
    audited_orders: 'OrderCreateManyNestedWithoutRelationsInput'
    sales_client_ids: List[_str]
    sales_clients: 'ClientCreateManyNestedWithoutRelationsInput'
    sales_order_ids: List[_str]
    sales_orders: 'OrderCreateManyNestedWithoutRelationsInput'
    tech_client_ids: List[_str]
    tech_clients: 'ClientCreateManyNestedWithoutRelationsInput'
    tech_order_ids: List[_str]
    tech_orders: 'OrderCreateManyNestedWithoutRelationsInput'


class AssociateCreateInput(AssociateOptionalCreateInput):
    """Required arguments to the Associate create method"""
    name: _str
    street_address_1: _str
    city: _str
    state: _str
    zip_code: _str
    phone: _str
    email: _str
    username: _str
    salt: _str
    w9_updated_at: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AssociateOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Associate create method, without relations"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    business_name: Optional[_str]
    street_address_2: Optional[_str]
    password: Optional[_str]
    salt_last_revealed_at: Optional[datetime.datetime]
    locked_at: Optional[datetime.datetime]
    ssn: Optional[_str]
    tin: Optional[_str]
    roles: List[_str]
    audited_order_ids: List[_str]
    sales_client_ids: List[_str]
    sales_order_ids: List[_str]
    tech_client_ids: List[_str]
    tech_order_ids: List[_str]


class AssociateCreateWithoutRelationsInput(AssociateOptionalCreateWithoutRelationsInput):
    """Required arguments to the Associate create method, without relations"""
    name: _str
    street_address_1: _str
    city: _str
    state: _str
    zip_code: _str
    phone: _str
    email: _str
    username: _str
    salt: _str
    w9_updated_at: datetime.datetime

class AssociateConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AssociateCreateWithoutRelationsInput'
    where: 'AssociateWhereUniqueInput'

class AssociateCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AssociateCreateWithoutRelationsInput'
    connect: 'AssociateWhereUniqueInput'
    connect_or_create: 'AssociateConnectOrCreateWithoutRelationsInput'


class AssociateCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AssociateCreateWithoutRelationsInput', List['AssociateCreateWithoutRelationsInput']]
    connect: Union['AssociateWhereUniqueInput', List['AssociateWhereUniqueInput']]
    connect_or_create: Union['AssociateConnectOrCreateWithoutRelationsInput', List['AssociateConnectOrCreateWithoutRelationsInput']]

_AssociateWhereUnique_id_Input = TypedDict(
    '_AssociateWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_AssociateWhereUnique_email_Input = TypedDict(
    '_AssociateWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

_AssociateWhereUnique_username_Input = TypedDict(
    '_AssociateWhereUnique_username_Input',
    {
        'username': '_str',
    },
    total=True
)

_AssociateWhereUnique_ssn_Input = TypedDict(
    '_AssociateWhereUnique_ssn_Input',
    {
        'ssn': '_str',
    },
    total=True
)

_AssociateWhereUnique_tin_Input = TypedDict(
    '_AssociateWhereUnique_tin_Input',
    {
        'tin': '_str',
    },
    total=True
)

AssociateWhereUniqueInput = Union[
    '_AssociateWhereUnique_id_Input',
    '_AssociateWhereUnique_email_Input',
    '_AssociateWhereUnique_username_Input',
    '_AssociateWhereUnique_ssn_Input',
    '_AssociateWhereUnique_tin_Input',
]


class AssociateUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    name: _str
    business_name: Optional[_str]
    street_address_1: _str
    street_address_2: Optional[_str]
    city: _str
    state: _str
    zip_code: _str
    phone: _str
    email: _str
    username: _str
    password: Optional[_str]
    salt: _str
    salt_last_revealed_at: Optional[datetime.datetime]
    locked_at: Optional[datetime.datetime]
    w9_updated_at: datetime.datetime
    ssn: Optional[_str]
    tin: Optional[_str]
    roles: 'types.StringListUpdate'
    audited_order_ids: 'types.StringListUpdate'
    audited_orders: 'OrderUpdateManyWithoutRelationsInput'
    sales_clients: 'ClientUpdateManyWithoutRelationsInput'
    sales_orders: 'OrderUpdateManyWithoutRelationsInput'
    tech_clients: 'ClientUpdateManyWithoutRelationsInput'
    tech_orders: 'OrderUpdateManyWithoutRelationsInput'


class AssociateUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    name: _str
    business_name: Optional[_str]
    street_address_1: _str
    street_address_2: Optional[_str]
    city: _str
    state: _str
    zip_code: _str
    phone: _str
    email: _str
    username: _str
    password: Optional[_str]
    salt: _str
    salt_last_revealed_at: Optional[datetime.datetime]
    locked_at: Optional[datetime.datetime]
    w9_updated_at: datetime.datetime
    ssn: Optional[_str]
    tin: Optional[_str]
    roles: 'types.StringListUpdate'
    audited_order_ids: 'types.StringListUpdate'


class AssociateUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AssociateCreateWithoutRelationsInput']
    connect: List['AssociateWhereUniqueInput']
    connect_or_create: List['AssociateConnectOrCreateWithoutRelationsInput']
    set: List['AssociateWhereUniqueInput']
    disconnect: List['AssociateWhereUniqueInput']
    delete: List['AssociateWhereUniqueInput']

    # TODO
    # update: List['AssociateUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AssociateUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AssociateScalarWhereInput']
    # upsert: List['AssociateUpserteWithWhereUniqueWithoutRelationsInput']


class AssociateUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AssociateCreateWithoutRelationsInput'
    connect: 'AssociateWhereUniqueInput'
    connect_or_create: 'AssociateConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AssociateUpdateInput'
    # upsert: 'AssociateUpsertWithoutRelationsInput'


class AssociateUpsertInput(TypedDict):
    create: 'AssociateCreateInput'
    update: 'AssociateUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Associate_id_OrderByInput = TypedDict(
    '_Associate_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Associate_created_at_OrderByInput = TypedDict(
    '_Associate_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Associate_updated_at_OrderByInput = TypedDict(
    '_Associate_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_Associate_name_OrderByInput = TypedDict(
    '_Associate_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Associate_business_name_OrderByInput = TypedDict(
    '_Associate_business_name_OrderByInput',
    {
        'business_name': 'SortOrder',
    },
    total=True
)

_Associate_street_address_1_OrderByInput = TypedDict(
    '_Associate_street_address_1_OrderByInput',
    {
        'street_address_1': 'SortOrder',
    },
    total=True
)

_Associate_street_address_2_OrderByInput = TypedDict(
    '_Associate_street_address_2_OrderByInput',
    {
        'street_address_2': 'SortOrder',
    },
    total=True
)

_Associate_city_OrderByInput = TypedDict(
    '_Associate_city_OrderByInput',
    {
        'city': 'SortOrder',
    },
    total=True
)

_Associate_state_OrderByInput = TypedDict(
    '_Associate_state_OrderByInput',
    {
        'state': 'SortOrder',
    },
    total=True
)

_Associate_zip_code_OrderByInput = TypedDict(
    '_Associate_zip_code_OrderByInput',
    {
        'zip_code': 'SortOrder',
    },
    total=True
)

_Associate_phone_OrderByInput = TypedDict(
    '_Associate_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Associate_email_OrderByInput = TypedDict(
    '_Associate_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Associate_username_OrderByInput = TypedDict(
    '_Associate_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_Associate_password_OrderByInput = TypedDict(
    '_Associate_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_Associate_salt_OrderByInput = TypedDict(
    '_Associate_salt_OrderByInput',
    {
        'salt': 'SortOrder',
    },
    total=True
)

_Associate_salt_last_revealed_at_OrderByInput = TypedDict(
    '_Associate_salt_last_revealed_at_OrderByInput',
    {
        'salt_last_revealed_at': 'SortOrder',
    },
    total=True
)

_Associate_locked_at_OrderByInput = TypedDict(
    '_Associate_locked_at_OrderByInput',
    {
        'locked_at': 'SortOrder',
    },
    total=True
)

_Associate_w9_updated_at_OrderByInput = TypedDict(
    '_Associate_w9_updated_at_OrderByInput',
    {
        'w9_updated_at': 'SortOrder',
    },
    total=True
)

_Associate_ssn_OrderByInput = TypedDict(
    '_Associate_ssn_OrderByInput',
    {
        'ssn': 'SortOrder',
    },
    total=True
)

_Associate_tin_OrderByInput = TypedDict(
    '_Associate_tin_OrderByInput',
    {
        'tin': 'SortOrder',
    },
    total=True
)

_Associate_roles_OrderByInput = TypedDict(
    '_Associate_roles_OrderByInput',
    {
        'roles': 'SortOrder',
    },
    total=True
)

_Associate_audited_order_ids_OrderByInput = TypedDict(
    '_Associate_audited_order_ids_OrderByInput',
    {
        'audited_order_ids': 'SortOrder',
    },
    total=True
)

_Associate_sales_client_ids_OrderByInput = TypedDict(
    '_Associate_sales_client_ids_OrderByInput',
    {
        'sales_client_ids': 'SortOrder',
    },
    total=True
)

_Associate_sales_order_ids_OrderByInput = TypedDict(
    '_Associate_sales_order_ids_OrderByInput',
    {
        'sales_order_ids': 'SortOrder',
    },
    total=True
)

_Associate_tech_client_ids_OrderByInput = TypedDict(
    '_Associate_tech_client_ids_OrderByInput',
    {
        'tech_client_ids': 'SortOrder',
    },
    total=True
)

_Associate_tech_order_ids_OrderByInput = TypedDict(
    '_Associate_tech_order_ids_OrderByInput',
    {
        'tech_order_ids': 'SortOrder',
    },
    total=True
)

AssociateOrderByInput = Union[
    '_Associate_id_OrderByInput',
    '_Associate_created_at_OrderByInput',
    '_Associate_updated_at_OrderByInput',
    '_Associate_name_OrderByInput',
    '_Associate_business_name_OrderByInput',
    '_Associate_street_address_1_OrderByInput',
    '_Associate_street_address_2_OrderByInput',
    '_Associate_city_OrderByInput',
    '_Associate_state_OrderByInput',
    '_Associate_zip_code_OrderByInput',
    '_Associate_phone_OrderByInput',
    '_Associate_email_OrderByInput',
    '_Associate_username_OrderByInput',
    '_Associate_password_OrderByInput',
    '_Associate_salt_OrderByInput',
    '_Associate_salt_last_revealed_at_OrderByInput',
    '_Associate_locked_at_OrderByInput',
    '_Associate_w9_updated_at_OrderByInput',
    '_Associate_ssn_OrderByInput',
    '_Associate_tin_OrderByInput',
    '_Associate_roles_OrderByInput',
    '_Associate_audited_order_ids_OrderByInput',
    '_Associate_sales_client_ids_OrderByInput',
    '_Associate_sales_order_ids_OrderByInput',
    '_Associate_tech_client_ids_OrderByInput',
    '_Associate_tech_order_ids_OrderByInput',
]



# recursive Associate types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

AssociateRelationFilter = TypedDict(
    'AssociateRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class AssociateListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class AssociateInclude(TypedDict, total=False):
    """Associate relational arguments"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromAssociate']
    sales_clients: Union[bool, 'FindManyClientArgsFromAssociate']
    sales_orders: Union[bool, 'FindManyOrderArgsFromAssociate']
    tech_clients: Union[bool, 'FindManyClientArgsFromAssociate']
    tech_orders: Union[bool, 'FindManyOrderArgsFromAssociate']


    

class AssociateIncludeFromAssociate(TypedDict, total=False):
    """Relational arguments for Associate"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive1']
    sales_clients: Union[bool, 'FindManyClientArgsFromAssociateRecursive1']
    sales_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive1']
    tech_clients: Union[bool, 'FindManyClientArgsFromAssociateRecursive1']
    tech_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive1']


class AssociateIncludeFromAssociateRecursive1(TypedDict, total=False):
    """Relational arguments for Associate"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive2']
    sales_clients: Union[bool, 'FindManyClientArgsFromAssociateRecursive2']
    sales_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive2']
    tech_clients: Union[bool, 'FindManyClientArgsFromAssociateRecursive2']
    tech_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive2']


class AssociateIncludeFromAssociateRecursive2(TypedDict, total=False):
    """Relational arguments for Associate"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive3']
    sales_clients: Union[bool, 'FindManyClientArgsFromAssociateRecursive3']
    sales_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive3']
    tech_clients: Union[bool, 'FindManyClientArgsFromAssociateRecursive3']
    tech_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive3']


class AssociateIncludeFromAssociateRecursive3(TypedDict, total=False):
    """Relational arguments for Associate"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive4']
    sales_clients: Union[bool, 'FindManyClientArgsFromAssociateRecursive4']
    sales_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive4']
    tech_clients: Union[bool, 'FindManyClientArgsFromAssociateRecursive4']
    tech_orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive4']


class AssociateIncludeFromAssociateRecursive4(TypedDict, total=False):
    """Relational arguments for Associate"""

    

class AssociateArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'AssociateIncludeFromAssociateRecursive1'


class AssociateArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'AssociateIncludeFromAssociateRecursive2'


class AssociateArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'AssociateIncludeFromAssociateRecursive3'


class AssociateArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'AssociateIncludeFromAssociateRecursive4'


class AssociateArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    
    

class FindManyAssociateArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive1'


class FindManyAssociateArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive2'


class FindManyAssociateArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive3'


class FindManyAssociateArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive4'


class FindManyAssociateArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    
    

class ClientIncludeFromAssociate(TypedDict, total=False):
    """Relational arguments for Associate"""
    orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive1']


class ClientIncludeFromAssociateRecursive1(TypedDict, total=False):
    """Relational arguments for Associate"""
    orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive2']


class ClientIncludeFromAssociateRecursive2(TypedDict, total=False):
    """Relational arguments for Associate"""
    orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive3']


class ClientIncludeFromAssociateRecursive3(TypedDict, total=False):
    """Relational arguments for Associate"""
    orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive4']


class ClientIncludeFromAssociateRecursive4(TypedDict, total=False):
    """Relational arguments for Associate"""

    

class ClientArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'ClientIncludeFromClientRecursive1'


class ClientArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'ClientIncludeFromClientRecursive2'


class ClientArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'ClientIncludeFromClientRecursive3'


class ClientArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'ClientIncludeFromClientRecursive4'


class ClientArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    
    

class FindManyClientArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive1'


class FindManyClientArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive2'


class FindManyClientArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive3'


class FindManyClientArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive4'


class FindManyClientArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    
    

class ProductIncludeFromAssociate(TypedDict, total=False):
    """Relational arguments for Associate"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromAssociateRecursive1']


class ProductIncludeFromAssociateRecursive1(TypedDict, total=False):
    """Relational arguments for Associate"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromAssociateRecursive2']


class ProductIncludeFromAssociateRecursive2(TypedDict, total=False):
    """Relational arguments for Associate"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromAssociateRecursive3']


class ProductIncludeFromAssociateRecursive3(TypedDict, total=False):
    """Relational arguments for Associate"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromAssociateRecursive4']


class ProductIncludeFromAssociateRecursive4(TypedDict, total=False):
    """Relational arguments for Associate"""

    

class ProductArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    
    

class FindManyProductArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class LineItemIncludeFromAssociate(TypedDict, total=False):
    """Relational arguments for Associate"""
    product: Union[bool, 'ProductArgsFromAssociateRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive1']


class LineItemIncludeFromAssociateRecursive1(TypedDict, total=False):
    """Relational arguments for Associate"""
    product: Union[bool, 'ProductArgsFromAssociateRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive2']


class LineItemIncludeFromAssociateRecursive2(TypedDict, total=False):
    """Relational arguments for Associate"""
    product: Union[bool, 'ProductArgsFromAssociateRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive3']


class LineItemIncludeFromAssociateRecursive3(TypedDict, total=False):
    """Relational arguments for Associate"""
    product: Union[bool, 'ProductArgsFromAssociateRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromAssociateRecursive4']


class LineItemIncludeFromAssociateRecursive4(TypedDict, total=False):
    """Relational arguments for Associate"""

    

class LineItemArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'LineItemIncludeFromLineItemRecursive1'


class LineItemArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'LineItemIncludeFromLineItemRecursive2'


class LineItemArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'LineItemIncludeFromLineItemRecursive3'


class LineItemArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'LineItemIncludeFromLineItemRecursive4'


class LineItemArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    
    

class FindManyLineItemArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive1'


class FindManyLineItemArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive2'


class FindManyLineItemArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive3'


class FindManyLineItemArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive4'


class FindManyLineItemArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    
    

class OrderIncludeFromAssociate(TypedDict, total=False):
    """Relational arguments for Associate"""
    audited_by: Union[bool, 'AssociateArgsFromAssociateRecursive1']
    client: Union[bool, 'ClientArgsFromAssociateRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive1']
    lineitems: Union[bool, 'FindManyLineItemArgsFromAssociateRecursive1']


class OrderIncludeFromAssociateRecursive1(TypedDict, total=False):
    """Relational arguments for Associate"""
    audited_by: Union[bool, 'AssociateArgsFromAssociateRecursive2']
    client: Union[bool, 'ClientArgsFromAssociateRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive2']
    lineitems: Union[bool, 'FindManyLineItemArgsFromAssociateRecursive2']


class OrderIncludeFromAssociateRecursive2(TypedDict, total=False):
    """Relational arguments for Associate"""
    audited_by: Union[bool, 'AssociateArgsFromAssociateRecursive3']
    client: Union[bool, 'ClientArgsFromAssociateRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive3']
    lineitems: Union[bool, 'FindManyLineItemArgsFromAssociateRecursive3']


class OrderIncludeFromAssociateRecursive3(TypedDict, total=False):
    """Relational arguments for Associate"""
    audited_by: Union[bool, 'AssociateArgsFromAssociateRecursive4']
    client: Union[bool, 'ClientArgsFromAssociateRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromAssociateRecursive4']
    lineitems: Union[bool, 'FindManyLineItemArgsFromAssociateRecursive4']


class OrderIncludeFromAssociateRecursive4(TypedDict, total=False):
    """Relational arguments for Associate"""

    

class OrderArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    
    

class FindManyOrderArgsFromAssociate(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromAssociateRecursive1(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromAssociateRecursive2(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromAssociateRecursive3(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromAssociateRecursive4(TypedDict, total=False):
    """Arguments for Associate"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    


FindManyAssociateArgs = FindManyAssociateArgsFromAssociate
FindFirstAssociateArgs = FindManyAssociateArgsFromAssociate


    

class AssociateWhereInput(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[None, _str, 'types.StringFilter']
    salt: Union[_str, 'types.StringFilter']
    salt_last_revealed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    locked_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    ssn: Union[None, _str, 'types.StringFilter']
    tin: Union[None, _str, 'types.StringFilter']
    roles: 'types.StringListFilter'
    audited_order_ids: 'types.StringListFilter'
    audited_orders: 'OrderListRelationFilter'
    sales_client_ids: 'types.StringListFilter'
    sales_clients: 'ClientListRelationFilter'
    sales_order_ids: 'types.StringListFilter'
    sales_orders: 'OrderListRelationFilter'
    tech_client_ids: 'types.StringListFilter'
    tech_clients: 'ClientListRelationFilter'
    tech_order_ids: 'types.StringListFilter'
    tech_orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['AssociateWhereInputRecursive1', List['AssociateWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['AssociateWhereInputRecursive1']
    OR: List['AssociateWhereInputRecursive1']
    NOT: List['AssociateWhereInputRecursive1']


class AssociateWhereInputRecursive1(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[None, _str, 'types.StringFilter']
    salt: Union[_str, 'types.StringFilter']
    salt_last_revealed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    locked_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    ssn: Union[None, _str, 'types.StringFilter']
    tin: Union[None, _str, 'types.StringFilter']
    roles: 'types.StringListFilter'
    audited_order_ids: 'types.StringListFilter'
    audited_orders: 'OrderListRelationFilter'
    sales_client_ids: 'types.StringListFilter'
    sales_clients: 'ClientListRelationFilter'
    sales_order_ids: 'types.StringListFilter'
    sales_orders: 'OrderListRelationFilter'
    tech_client_ids: 'types.StringListFilter'
    tech_clients: 'ClientListRelationFilter'
    tech_order_ids: 'types.StringListFilter'
    tech_orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['AssociateWhereInputRecursive2', List['AssociateWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['AssociateWhereInputRecursive2']
    OR: List['AssociateWhereInputRecursive2']
    NOT: List['AssociateWhereInputRecursive2']


class AssociateWhereInputRecursive2(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[None, _str, 'types.StringFilter']
    salt: Union[_str, 'types.StringFilter']
    salt_last_revealed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    locked_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    ssn: Union[None, _str, 'types.StringFilter']
    tin: Union[None, _str, 'types.StringFilter']
    roles: 'types.StringListFilter'
    audited_order_ids: 'types.StringListFilter'
    audited_orders: 'OrderListRelationFilter'
    sales_client_ids: 'types.StringListFilter'
    sales_clients: 'ClientListRelationFilter'
    sales_order_ids: 'types.StringListFilter'
    sales_orders: 'OrderListRelationFilter'
    tech_client_ids: 'types.StringListFilter'
    tech_clients: 'ClientListRelationFilter'
    tech_order_ids: 'types.StringListFilter'
    tech_orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['AssociateWhereInputRecursive3', List['AssociateWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['AssociateWhereInputRecursive3']
    OR: List['AssociateWhereInputRecursive3']
    NOT: List['AssociateWhereInputRecursive3']


class AssociateWhereInputRecursive3(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[None, _str, 'types.StringFilter']
    salt: Union[_str, 'types.StringFilter']
    salt_last_revealed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    locked_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    ssn: Union[None, _str, 'types.StringFilter']
    tin: Union[None, _str, 'types.StringFilter']
    roles: 'types.StringListFilter'
    audited_order_ids: 'types.StringListFilter'
    audited_orders: 'OrderListRelationFilter'
    sales_client_ids: 'types.StringListFilter'
    sales_clients: 'ClientListRelationFilter'
    sales_order_ids: 'types.StringListFilter'
    sales_orders: 'OrderListRelationFilter'
    tech_client_ids: 'types.StringListFilter'
    tech_clients: 'ClientListRelationFilter'
    tech_order_ids: 'types.StringListFilter'
    tech_orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['AssociateWhereInputRecursive4', List['AssociateWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['AssociateWhereInputRecursive4']
    OR: List['AssociateWhereInputRecursive4']
    NOT: List['AssociateWhereInputRecursive4']


class AssociateWhereInputRecursive4(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    password: Union[None, _str, 'types.StringFilter']
    salt: Union[_str, 'types.StringFilter']
    salt_last_revealed_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    locked_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    ssn: Union[None, _str, 'types.StringFilter']
    tin: Union[None, _str, 'types.StringFilter']
    roles: 'types.StringListFilter'
    audited_order_ids: 'types.StringListFilter'
    audited_orders: 'OrderListRelationFilter'
    sales_client_ids: 'types.StringListFilter'
    sales_clients: 'ClientListRelationFilter'
    sales_order_ids: 'types.StringListFilter'
    sales_orders: 'OrderListRelationFilter'
    tech_client_ids: 'types.StringListFilter'
    tech_clients: 'ClientListRelationFilter'
    tech_order_ids: 'types.StringListFilter'
    tech_orders: 'OrderListRelationFilter'



# aggregate Associate types


    

class AssociateScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    salt: Union[_str, 'types.StringWithAggregatesFilter']
    salt_last_revealed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    locked_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ssn: Union[_str, 'types.StringWithAggregatesFilter']
    tin: Union[_str, 'types.StringWithAggregatesFilter']
    roles: Union[_str, 'types.StringWithAggregatesFilter']
    audited_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_order_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AssociateScalarWhereWithAggregatesInputRecursive1']
    OR: List['AssociateScalarWhereWithAggregatesInputRecursive1']
    NOT: List['AssociateScalarWhereWithAggregatesInputRecursive1']


class AssociateScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    salt: Union[_str, 'types.StringWithAggregatesFilter']
    salt_last_revealed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    locked_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ssn: Union[_str, 'types.StringWithAggregatesFilter']
    tin: Union[_str, 'types.StringWithAggregatesFilter']
    roles: Union[_str, 'types.StringWithAggregatesFilter']
    audited_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_order_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AssociateScalarWhereWithAggregatesInputRecursive2']
    OR: List['AssociateScalarWhereWithAggregatesInputRecursive2']
    NOT: List['AssociateScalarWhereWithAggregatesInputRecursive2']


class AssociateScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    salt: Union[_str, 'types.StringWithAggregatesFilter']
    salt_last_revealed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    locked_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ssn: Union[_str, 'types.StringWithAggregatesFilter']
    tin: Union[_str, 'types.StringWithAggregatesFilter']
    roles: Union[_str, 'types.StringWithAggregatesFilter']
    audited_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_order_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AssociateScalarWhereWithAggregatesInputRecursive3']
    OR: List['AssociateScalarWhereWithAggregatesInputRecursive3']
    NOT: List['AssociateScalarWhereWithAggregatesInputRecursive3']


class AssociateScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    salt: Union[_str, 'types.StringWithAggregatesFilter']
    salt_last_revealed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    locked_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ssn: Union[_str, 'types.StringWithAggregatesFilter']
    tin: Union[_str, 'types.StringWithAggregatesFilter']
    roles: Union[_str, 'types.StringWithAggregatesFilter']
    audited_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_order_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['AssociateScalarWhereWithAggregatesInputRecursive4']
    OR: List['AssociateScalarWhereWithAggregatesInputRecursive4']
    NOT: List['AssociateScalarWhereWithAggregatesInputRecursive4']


class AssociateScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Associate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    salt: Union[_str, 'types.StringWithAggregatesFilter']
    salt_last_revealed_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    locked_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    w9_updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ssn: Union[_str, 'types.StringWithAggregatesFilter']
    tin: Union[_str, 'types.StringWithAggregatesFilter']
    roles: Union[_str, 'types.StringWithAggregatesFilter']
    audited_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_client_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_order_ids: Union[_str, 'types.StringWithAggregatesFilter']



class AssociateGroupByOutput(TypedDict, total=False):
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    name: _str
    business_name: _str
    street_address_1: _str
    street_address_2: _str
    city: _str
    state: _str
    zip_code: _str
    phone: _str
    email: _str
    username: _str
    password: _str
    salt: _str
    salt_last_revealed_at: datetime.datetime
    locked_at: datetime.datetime
    w9_updated_at: datetime.datetime
    ssn: _str
    tin: _str
    roles: List[_str]
    audited_order_ids: List[_str]
    sales_client_ids: List[_str]
    sales_order_ids: List[_str]
    tech_client_ids: List[_str]
    tech_order_ids: List[_str]
    _sum: 'AssociateSumAggregateOutput'
    _avg: 'AssociateAvgAggregateOutput'
    _min: 'AssociateMinAggregateOutput'
    _max: 'AssociateMaxAggregateOutput'
    _count: 'AssociateCountAggregateOutput'


class AssociateAvgAggregateOutput(TypedDict, total=False):
    """Associate output for aggregating averages"""


class AssociateSumAggregateOutput(TypedDict, total=False):
    """Associate output for aggregating sums"""


class AssociateScalarAggregateOutput(TypedDict, total=False):
    """Associate output including scalar fields"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    name: _str
    business_name: _str
    street_address_1: _str
    street_address_2: _str
    city: _str
    state: _str
    zip_code: _str
    phone: _str
    email: _str
    username: _str
    password: _str
    salt: _str
    salt_last_revealed_at: datetime.datetime
    locked_at: datetime.datetime
    w9_updated_at: datetime.datetime
    ssn: _str
    tin: _str
    roles: List[_str]
    audited_order_ids: List[_str]
    sales_client_ids: List[_str]
    sales_order_ids: List[_str]
    tech_client_ids: List[_str]
    tech_order_ids: List[_str]


AssociateMinAggregateOutput = AssociateScalarAggregateOutput
AssociateMaxAggregateOutput = AssociateScalarAggregateOutput


class AssociateMaxAggregateInput(TypedDict, total=False):
    """Associate input for aggregating by max"""
    id: bool
    created_at: bool
    updated_at: bool
    name: bool
    business_name: bool
    street_address_1: bool
    street_address_2: bool
    city: bool
    state: bool
    zip_code: bool
    phone: bool
    email: bool
    username: bool
    password: bool
    salt: bool
    salt_last_revealed_at: bool
    locked_at: bool
    w9_updated_at: bool
    ssn: bool
    tin: bool
    roles: bool
    audited_order_ids: bool
    sales_client_ids: bool
    sales_order_ids: bool
    tech_client_ids: bool
    tech_order_ids: bool


class AssociateMinAggregateInput(TypedDict, total=False):
    """Associate input for aggregating by min"""
    id: bool
    created_at: bool
    updated_at: bool
    name: bool
    business_name: bool
    street_address_1: bool
    street_address_2: bool
    city: bool
    state: bool
    zip_code: bool
    phone: bool
    email: bool
    username: bool
    password: bool
    salt: bool
    salt_last_revealed_at: bool
    locked_at: bool
    w9_updated_at: bool
    ssn: bool
    tin: bool
    roles: bool
    audited_order_ids: bool
    sales_client_ids: bool
    sales_order_ids: bool
    tech_client_ids: bool
    tech_order_ids: bool


class AssociateNumberAggregateInput(TypedDict, total=False):
    """Associate input for aggregating numbers"""


AssociateAvgAggregateInput = AssociateNumberAggregateInput
AssociateSumAggregateInput = AssociateNumberAggregateInput


AssociateCountAggregateInput = TypedDict(
    'AssociateCountAggregateInput',
    {
        'id': bool,
        'created_at': bool,
        'updated_at': bool,
        'name': bool,
        'business_name': bool,
        'street_address_1': bool,
        'street_address_2': bool,
        'city': bool,
        'state': bool,
        'zip_code': bool,
        'phone': bool,
        'email': bool,
        'username': bool,
        'password': bool,
        'salt': bool,
        'salt_last_revealed_at': bool,
        'locked_at': bool,
        'w9_updated_at': bool,
        'ssn': bool,
        'tin': bool,
        'roles': bool,
        'audited_order_ids': bool,
        'sales_client_ids': bool,
        'sales_order_ids': bool,
        'tech_client_ids': bool,
        'tech_order_ids': bool,
        '_all': bool,
    },
    total=False,
)

AssociateCountAggregateOutput = TypedDict(
    'AssociateCountAggregateOutput',
    {
        'id': int,
        'created_at': int,
        'updated_at': int,
        'name': int,
        'business_name': int,
        'street_address_1': int,
        'street_address_2': int,
        'city': int,
        'state': int,
        'zip_code': int,
        'phone': int,
        'email': int,
        'username': int,
        'password': int,
        'salt': int,
        'salt_last_revealed_at': int,
        'locked_at': int,
        'w9_updated_at': int,
        'ssn': int,
        'tin': int,
        'roles': int,
        'audited_order_ids': int,
        'sales_client_ids': int,
        'sales_order_ids': int,
        'tech_client_ids': int,
        'tech_order_ids': int,
        '_all': int,
    },
    total=False,
)


AssociateKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'name',
    'business_name',
    'street_address_1',
    'street_address_2',
    'city',
    'state',
    'zip_code',
    'phone',
    'email',
    'username',
    'password',
    'salt',
    'salt_last_revealed_at',
    'locked_at',
    'w9_updated_at',
    'ssn',
    'tin',
    'roles',
    'audited_order_ids',
    'audited_orders',
    'sales_client_ids',
    'sales_clients',
    'sales_order_ids',
    'sales_orders',
    'tech_client_ids',
    'tech_clients',
    'tech_order_ids',
    'tech_orders',
]
AssociateScalarFieldKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'name',
    'business_name',
    'street_address_1',
    'street_address_2',
    'city',
    'state',
    'zip_code',
    'phone',
    'email',
    'username',
    'password',
    'salt',
    'salt_last_revealed_at',
    'locked_at',
    'w9_updated_at',
    'ssn',
    'tin',
    'roles',
    'audited_order_ids',
    'sales_client_ids',
    'sales_order_ids',
    'tech_client_ids',
    'tech_order_ids',
]
AssociateScalarFieldKeysT = TypeVar('AssociateScalarFieldKeysT', bound=AssociateScalarFieldKeys)

AssociateRelationalFieldKeys = Literal[
        'audited_orders',
        'sales_clients',
        'sales_orders',
        'tech_clients',
        'tech_orders',
    ]

# Client types

class ClientOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Client create method"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    status: _str
    business_name: Optional[_str]
    street_address_2: Optional[_str]
    order_ids: List[_str]
    orders: 'OrderCreateManyNestedWithoutRelationsInput'
    sales_associate_ids: List[_str]
    sales_associates: 'AssociateCreateManyNestedWithoutRelationsInput'
    tech_associate_ids: List[_str]
    tech_associates: 'AssociateCreateManyNestedWithoutRelationsInput'


class ClientCreateInput(ClientOptionalCreateInput):
    """Required arguments to the Client create method"""
    account_number: _str
    contact_name: _str
    email: _str
    phone: _str
    street_address_1: _str
    city: _str
    state: _str
    zip_code: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ClientOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Client create method, without relations"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    status: _str
    business_name: Optional[_str]
    street_address_2: Optional[_str]
    order_ids: List[_str]
    sales_associate_ids: List[_str]
    tech_associate_ids: List[_str]


class ClientCreateWithoutRelationsInput(ClientOptionalCreateWithoutRelationsInput):
    """Required arguments to the Client create method, without relations"""
    account_number: _str
    contact_name: _str
    email: _str
    phone: _str
    street_address_1: _str
    city: _str
    state: _str
    zip_code: _str

class ClientConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ClientCreateWithoutRelationsInput'
    where: 'ClientWhereUniqueInput'

class ClientCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ClientCreateWithoutRelationsInput'
    connect: 'ClientWhereUniqueInput'
    connect_or_create: 'ClientConnectOrCreateWithoutRelationsInput'


class ClientCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ClientCreateWithoutRelationsInput', List['ClientCreateWithoutRelationsInput']]
    connect: Union['ClientWhereUniqueInput', List['ClientWhereUniqueInput']]
    connect_or_create: Union['ClientConnectOrCreateWithoutRelationsInput', List['ClientConnectOrCreateWithoutRelationsInput']]

_ClientWhereUnique_id_Input = TypedDict(
    '_ClientWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_ClientWhereUnique_account_number_Input = TypedDict(
    '_ClientWhereUnique_account_number_Input',
    {
        'account_number': '_str',
    },
    total=True
)

_ClientWhereUnique_email_Input = TypedDict(
    '_ClientWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

ClientWhereUniqueInput = Union[
    '_ClientWhereUnique_id_Input',
    '_ClientWhereUnique_account_number_Input',
    '_ClientWhereUnique_email_Input',
]


class ClientUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    account_number: _str
    status: _str
    contact_name: _str
    email: _str
    phone: _str
    business_name: Optional[_str]
    street_address_1: _str
    street_address_2: Optional[_str]
    city: _str
    state: _str
    zip_code: _str
    order_ids: 'types.StringListUpdate'
    orders: 'OrderUpdateManyWithoutRelationsInput'
    sales_associates: 'AssociateUpdateManyWithoutRelationsInput'
    tech_associates: 'AssociateUpdateManyWithoutRelationsInput'


class ClientUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    account_number: _str
    status: _str
    contact_name: _str
    email: _str
    phone: _str
    business_name: Optional[_str]
    street_address_1: _str
    street_address_2: Optional[_str]
    city: _str
    state: _str
    zip_code: _str
    order_ids: 'types.StringListUpdate'


class ClientUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ClientCreateWithoutRelationsInput']
    connect: List['ClientWhereUniqueInput']
    connect_or_create: List['ClientConnectOrCreateWithoutRelationsInput']
    set: List['ClientWhereUniqueInput']
    disconnect: List['ClientWhereUniqueInput']
    delete: List['ClientWhereUniqueInput']

    # TODO
    # update: List['ClientUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ClientUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ClientScalarWhereInput']
    # upsert: List['ClientUpserteWithWhereUniqueWithoutRelationsInput']


class ClientUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ClientCreateWithoutRelationsInput'
    connect: 'ClientWhereUniqueInput'
    connect_or_create: 'ClientConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ClientUpdateInput'
    # upsert: 'ClientUpsertWithoutRelationsInput'


class ClientUpsertInput(TypedDict):
    create: 'ClientCreateInput'
    update: 'ClientUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Client_id_OrderByInput = TypedDict(
    '_Client_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Client_created_at_OrderByInput = TypedDict(
    '_Client_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Client_updated_at_OrderByInput = TypedDict(
    '_Client_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_Client_account_number_OrderByInput = TypedDict(
    '_Client_account_number_OrderByInput',
    {
        'account_number': 'SortOrder',
    },
    total=True
)

_Client_status_OrderByInput = TypedDict(
    '_Client_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Client_contact_name_OrderByInput = TypedDict(
    '_Client_contact_name_OrderByInput',
    {
        'contact_name': 'SortOrder',
    },
    total=True
)

_Client_email_OrderByInput = TypedDict(
    '_Client_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Client_phone_OrderByInput = TypedDict(
    '_Client_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Client_business_name_OrderByInput = TypedDict(
    '_Client_business_name_OrderByInput',
    {
        'business_name': 'SortOrder',
    },
    total=True
)

_Client_street_address_1_OrderByInput = TypedDict(
    '_Client_street_address_1_OrderByInput',
    {
        'street_address_1': 'SortOrder',
    },
    total=True
)

_Client_street_address_2_OrderByInput = TypedDict(
    '_Client_street_address_2_OrderByInput',
    {
        'street_address_2': 'SortOrder',
    },
    total=True
)

_Client_city_OrderByInput = TypedDict(
    '_Client_city_OrderByInput',
    {
        'city': 'SortOrder',
    },
    total=True
)

_Client_state_OrderByInput = TypedDict(
    '_Client_state_OrderByInput',
    {
        'state': 'SortOrder',
    },
    total=True
)

_Client_zip_code_OrderByInput = TypedDict(
    '_Client_zip_code_OrderByInput',
    {
        'zip_code': 'SortOrder',
    },
    total=True
)

_Client_order_ids_OrderByInput = TypedDict(
    '_Client_order_ids_OrderByInput',
    {
        'order_ids': 'SortOrder',
    },
    total=True
)

_Client_sales_associate_ids_OrderByInput = TypedDict(
    '_Client_sales_associate_ids_OrderByInput',
    {
        'sales_associate_ids': 'SortOrder',
    },
    total=True
)

_Client_tech_associate_ids_OrderByInput = TypedDict(
    '_Client_tech_associate_ids_OrderByInput',
    {
        'tech_associate_ids': 'SortOrder',
    },
    total=True
)

ClientOrderByInput = Union[
    '_Client_id_OrderByInput',
    '_Client_created_at_OrderByInput',
    '_Client_updated_at_OrderByInput',
    '_Client_account_number_OrderByInput',
    '_Client_status_OrderByInput',
    '_Client_contact_name_OrderByInput',
    '_Client_email_OrderByInput',
    '_Client_phone_OrderByInput',
    '_Client_business_name_OrderByInput',
    '_Client_street_address_1_OrderByInput',
    '_Client_street_address_2_OrderByInput',
    '_Client_city_OrderByInput',
    '_Client_state_OrderByInput',
    '_Client_zip_code_OrderByInput',
    '_Client_order_ids_OrderByInput',
    '_Client_sales_associate_ids_OrderByInput',
    '_Client_tech_associate_ids_OrderByInput',
]



# recursive Client types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ClientRelationFilter = TypedDict(
    'ClientRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ClientListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ClientInclude(TypedDict, total=False):
    """Client relational arguments"""
    orders: Union[bool, 'FindManyOrderArgsFromClient']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClient']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClient']


    

class AssociateIncludeFromClient(TypedDict, total=False):
    """Relational arguments for Client"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive1']
    sales_clients: Union[bool, 'FindManyClientArgsFromClientRecursive1']
    sales_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive1']
    tech_clients: Union[bool, 'FindManyClientArgsFromClientRecursive1']
    tech_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive1']


class AssociateIncludeFromClientRecursive1(TypedDict, total=False):
    """Relational arguments for Client"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive2']
    sales_clients: Union[bool, 'FindManyClientArgsFromClientRecursive2']
    sales_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive2']
    tech_clients: Union[bool, 'FindManyClientArgsFromClientRecursive2']
    tech_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive2']


class AssociateIncludeFromClientRecursive2(TypedDict, total=False):
    """Relational arguments for Client"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive3']
    sales_clients: Union[bool, 'FindManyClientArgsFromClientRecursive3']
    sales_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive3']
    tech_clients: Union[bool, 'FindManyClientArgsFromClientRecursive3']
    tech_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive3']


class AssociateIncludeFromClientRecursive3(TypedDict, total=False):
    """Relational arguments for Client"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive4']
    sales_clients: Union[bool, 'FindManyClientArgsFromClientRecursive4']
    sales_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive4']
    tech_clients: Union[bool, 'FindManyClientArgsFromClientRecursive4']
    tech_orders: Union[bool, 'FindManyOrderArgsFromClientRecursive4']


class AssociateIncludeFromClientRecursive4(TypedDict, total=False):
    """Relational arguments for Client"""

    

class AssociateArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    include: 'AssociateIncludeFromAssociateRecursive1'


class AssociateArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    include: 'AssociateIncludeFromAssociateRecursive2'


class AssociateArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    include: 'AssociateIncludeFromAssociateRecursive3'


class AssociateArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    include: 'AssociateIncludeFromAssociateRecursive4'


class AssociateArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    
    

class FindManyAssociateArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive1'


class FindManyAssociateArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive2'


class FindManyAssociateArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive3'


class FindManyAssociateArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive4'


class FindManyAssociateArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    
    

class ClientIncludeFromClient(TypedDict, total=False):
    """Relational arguments for Client"""
    orders: Union[bool, 'FindManyOrderArgsFromClientRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive1']


class ClientIncludeFromClientRecursive1(TypedDict, total=False):
    """Relational arguments for Client"""
    orders: Union[bool, 'FindManyOrderArgsFromClientRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive2']


class ClientIncludeFromClientRecursive2(TypedDict, total=False):
    """Relational arguments for Client"""
    orders: Union[bool, 'FindManyOrderArgsFromClientRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive3']


class ClientIncludeFromClientRecursive3(TypedDict, total=False):
    """Relational arguments for Client"""
    orders: Union[bool, 'FindManyOrderArgsFromClientRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive4']


class ClientIncludeFromClientRecursive4(TypedDict, total=False):
    """Relational arguments for Client"""

    

class ClientArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    include: 'ClientIncludeFromClientRecursive1'


class ClientArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    include: 'ClientIncludeFromClientRecursive2'


class ClientArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    include: 'ClientIncludeFromClientRecursive3'


class ClientArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    include: 'ClientIncludeFromClientRecursive4'


class ClientArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    
    

class FindManyClientArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive1'


class FindManyClientArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive2'


class FindManyClientArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive3'


class FindManyClientArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive4'


class FindManyClientArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    
    

class ProductIncludeFromClient(TypedDict, total=False):
    """Relational arguments for Client"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromClientRecursive1']


class ProductIncludeFromClientRecursive1(TypedDict, total=False):
    """Relational arguments for Client"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromClientRecursive2']


class ProductIncludeFromClientRecursive2(TypedDict, total=False):
    """Relational arguments for Client"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromClientRecursive3']


class ProductIncludeFromClientRecursive3(TypedDict, total=False):
    """Relational arguments for Client"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromClientRecursive4']


class ProductIncludeFromClientRecursive4(TypedDict, total=False):
    """Relational arguments for Client"""

    

class ProductArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    
    

class FindManyProductArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class LineItemIncludeFromClient(TypedDict, total=False):
    """Relational arguments for Client"""
    product: Union[bool, 'ProductArgsFromClientRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromClientRecursive1']


class LineItemIncludeFromClientRecursive1(TypedDict, total=False):
    """Relational arguments for Client"""
    product: Union[bool, 'ProductArgsFromClientRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromClientRecursive2']


class LineItemIncludeFromClientRecursive2(TypedDict, total=False):
    """Relational arguments for Client"""
    product: Union[bool, 'ProductArgsFromClientRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromClientRecursive3']


class LineItemIncludeFromClientRecursive3(TypedDict, total=False):
    """Relational arguments for Client"""
    product: Union[bool, 'ProductArgsFromClientRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromClientRecursive4']


class LineItemIncludeFromClientRecursive4(TypedDict, total=False):
    """Relational arguments for Client"""

    

class LineItemArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    include: 'LineItemIncludeFromLineItemRecursive1'


class LineItemArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    include: 'LineItemIncludeFromLineItemRecursive2'


class LineItemArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    include: 'LineItemIncludeFromLineItemRecursive3'


class LineItemArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    include: 'LineItemIncludeFromLineItemRecursive4'


class LineItemArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    
    

class FindManyLineItemArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive1'


class FindManyLineItemArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive2'


class FindManyLineItemArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive3'


class FindManyLineItemArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive4'


class FindManyLineItemArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    
    

class OrderIncludeFromClient(TypedDict, total=False):
    """Relational arguments for Client"""
    audited_by: Union[bool, 'AssociateArgsFromClientRecursive1']
    client: Union[bool, 'ClientArgsFromClientRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive1']
    lineitems: Union[bool, 'FindManyLineItemArgsFromClientRecursive1']


class OrderIncludeFromClientRecursive1(TypedDict, total=False):
    """Relational arguments for Client"""
    audited_by: Union[bool, 'AssociateArgsFromClientRecursive2']
    client: Union[bool, 'ClientArgsFromClientRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive2']
    lineitems: Union[bool, 'FindManyLineItemArgsFromClientRecursive2']


class OrderIncludeFromClientRecursive2(TypedDict, total=False):
    """Relational arguments for Client"""
    audited_by: Union[bool, 'AssociateArgsFromClientRecursive3']
    client: Union[bool, 'ClientArgsFromClientRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive3']
    lineitems: Union[bool, 'FindManyLineItemArgsFromClientRecursive3']


class OrderIncludeFromClientRecursive3(TypedDict, total=False):
    """Relational arguments for Client"""
    audited_by: Union[bool, 'AssociateArgsFromClientRecursive4']
    client: Union[bool, 'ClientArgsFromClientRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromClientRecursive4']
    lineitems: Union[bool, 'FindManyLineItemArgsFromClientRecursive4']


class OrderIncludeFromClientRecursive4(TypedDict, total=False):
    """Relational arguments for Client"""

    

class OrderArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    
    

class FindManyOrderArgsFromClient(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromClientRecursive1(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromClientRecursive2(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromClientRecursive3(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromClientRecursive4(TypedDict, total=False):
    """Arguments for Client"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    


FindManyClientArgs = FindManyClientArgsFromClient
FindFirstClientArgs = FindManyClientArgsFromClient


    

class ClientWhereInput(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    account_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    contact_name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'

    # should be noted that AND and NOT should be Union['ClientWhereInputRecursive1', List['ClientWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ClientWhereInputRecursive1']
    OR: List['ClientWhereInputRecursive1']
    NOT: List['ClientWhereInputRecursive1']


class ClientWhereInputRecursive1(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    account_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    contact_name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'

    # should be noted that AND and NOT should be Union['ClientWhereInputRecursive2', List['ClientWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ClientWhereInputRecursive2']
    OR: List['ClientWhereInputRecursive2']
    NOT: List['ClientWhereInputRecursive2']


class ClientWhereInputRecursive2(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    account_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    contact_name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'

    # should be noted that AND and NOT should be Union['ClientWhereInputRecursive3', List['ClientWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ClientWhereInputRecursive3']
    OR: List['ClientWhereInputRecursive3']
    NOT: List['ClientWhereInputRecursive3']


class ClientWhereInputRecursive3(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    account_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    contact_name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'

    # should be noted that AND and NOT should be Union['ClientWhereInputRecursive4', List['ClientWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ClientWhereInputRecursive4']
    OR: List['ClientWhereInputRecursive4']
    NOT: List['ClientWhereInputRecursive4']


class ClientWhereInputRecursive4(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    account_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    contact_name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[_str, 'types.StringFilter']
    business_name: Union[None, _str, 'types.StringFilter']
    street_address_1: Union[_str, 'types.StringFilter']
    street_address_2: Union[None, _str, 'types.StringFilter']
    city: Union[_str, 'types.StringFilter']
    state: Union[_str, 'types.StringFilter']
    zip_code: Union[_str, 'types.StringFilter']
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'



# aggregate Client types


    

class ClientScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    account_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    contact_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ClientScalarWhereWithAggregatesInputRecursive1']
    OR: List['ClientScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ClientScalarWhereWithAggregatesInputRecursive1']


class ClientScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    account_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    contact_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ClientScalarWhereWithAggregatesInputRecursive2']
    OR: List['ClientScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ClientScalarWhereWithAggregatesInputRecursive2']


class ClientScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    account_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    contact_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ClientScalarWhereWithAggregatesInputRecursive3']
    OR: List['ClientScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ClientScalarWhereWithAggregatesInputRecursive3']


class ClientScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    account_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    contact_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ClientScalarWhereWithAggregatesInputRecursive4']
    OR: List['ClientScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ClientScalarWhereWithAggregatesInputRecursive4']


class ClientScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Client arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    account_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    contact_name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    business_name: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_1: Union[_str, 'types.StringWithAggregatesFilter']
    street_address_2: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    zip_code: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']



class ClientGroupByOutput(TypedDict, total=False):
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    account_number: _str
    status: _str
    contact_name: _str
    email: _str
    phone: _str
    business_name: _str
    street_address_1: _str
    street_address_2: _str
    city: _str
    state: _str
    zip_code: _str
    order_ids: List[_str]
    sales_associate_ids: List[_str]
    tech_associate_ids: List[_str]
    _sum: 'ClientSumAggregateOutput'
    _avg: 'ClientAvgAggregateOutput'
    _min: 'ClientMinAggregateOutput'
    _max: 'ClientMaxAggregateOutput'
    _count: 'ClientCountAggregateOutput'


class ClientAvgAggregateOutput(TypedDict, total=False):
    """Client output for aggregating averages"""


class ClientSumAggregateOutput(TypedDict, total=False):
    """Client output for aggregating sums"""


class ClientScalarAggregateOutput(TypedDict, total=False):
    """Client output including scalar fields"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    account_number: _str
    status: _str
    contact_name: _str
    email: _str
    phone: _str
    business_name: _str
    street_address_1: _str
    street_address_2: _str
    city: _str
    state: _str
    zip_code: _str
    order_ids: List[_str]
    sales_associate_ids: List[_str]
    tech_associate_ids: List[_str]


ClientMinAggregateOutput = ClientScalarAggregateOutput
ClientMaxAggregateOutput = ClientScalarAggregateOutput


class ClientMaxAggregateInput(TypedDict, total=False):
    """Client input for aggregating by max"""
    id: bool
    created_at: bool
    updated_at: bool
    account_number: bool
    status: bool
    contact_name: bool
    email: bool
    phone: bool
    business_name: bool
    street_address_1: bool
    street_address_2: bool
    city: bool
    state: bool
    zip_code: bool
    order_ids: bool
    sales_associate_ids: bool
    tech_associate_ids: bool


class ClientMinAggregateInput(TypedDict, total=False):
    """Client input for aggregating by min"""
    id: bool
    created_at: bool
    updated_at: bool
    account_number: bool
    status: bool
    contact_name: bool
    email: bool
    phone: bool
    business_name: bool
    street_address_1: bool
    street_address_2: bool
    city: bool
    state: bool
    zip_code: bool
    order_ids: bool
    sales_associate_ids: bool
    tech_associate_ids: bool


class ClientNumberAggregateInput(TypedDict, total=False):
    """Client input for aggregating numbers"""


ClientAvgAggregateInput = ClientNumberAggregateInput
ClientSumAggregateInput = ClientNumberAggregateInput


ClientCountAggregateInput = TypedDict(
    'ClientCountAggregateInput',
    {
        'id': bool,
        'created_at': bool,
        'updated_at': bool,
        'account_number': bool,
        'status': bool,
        'contact_name': bool,
        'email': bool,
        'phone': bool,
        'business_name': bool,
        'street_address_1': bool,
        'street_address_2': bool,
        'city': bool,
        'state': bool,
        'zip_code': bool,
        'order_ids': bool,
        'sales_associate_ids': bool,
        'tech_associate_ids': bool,
        '_all': bool,
    },
    total=False,
)

ClientCountAggregateOutput = TypedDict(
    'ClientCountAggregateOutput',
    {
        'id': int,
        'created_at': int,
        'updated_at': int,
        'account_number': int,
        'status': int,
        'contact_name': int,
        'email': int,
        'phone': int,
        'business_name': int,
        'street_address_1': int,
        'street_address_2': int,
        'city': int,
        'state': int,
        'zip_code': int,
        'order_ids': int,
        'sales_associate_ids': int,
        'tech_associate_ids': int,
        '_all': int,
    },
    total=False,
)


ClientKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'account_number',
    'status',
    'contact_name',
    'email',
    'phone',
    'business_name',
    'street_address_1',
    'street_address_2',
    'city',
    'state',
    'zip_code',
    'order_ids',
    'orders',
    'sales_associate_ids',
    'sales_associates',
    'tech_associate_ids',
    'tech_associates',
]
ClientScalarFieldKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'account_number',
    'status',
    'contact_name',
    'email',
    'phone',
    'business_name',
    'street_address_1',
    'street_address_2',
    'city',
    'state',
    'zip_code',
    'order_ids',
    'sales_associate_ids',
    'tech_associate_ids',
]
ClientScalarFieldKeysT = TypeVar('ClientScalarFieldKeysT', bound=ClientScalarFieldKeys)

ClientRelationalFieldKeys = Literal[
        'orders',
        'sales_associates',
        'tech_associates',
    ]

# Product types

class ProductOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Product create method"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    description: Optional[_str]
    lineitem_ids: List[_str]
    lineitems: 'LineItemCreateManyNestedWithoutRelationsInput'


class ProductCreateInput(ProductOptionalCreateInput):
    """Required arguments to the Product create method"""
    name: _str
    unit: _str
    unit_price: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProductOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Product create method, without relations"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    description: Optional[_str]
    lineitem_ids: List[_str]


class ProductCreateWithoutRelationsInput(ProductOptionalCreateWithoutRelationsInput):
    """Required arguments to the Product create method, without relations"""
    name: _str
    unit: _str
    unit_price: _int

class ProductConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ProductCreateWithoutRelationsInput'
    where: 'ProductWhereUniqueInput'

class ProductCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProductCreateWithoutRelationsInput'
    connect: 'ProductWhereUniqueInput'
    connect_or_create: 'ProductConnectOrCreateWithoutRelationsInput'


class ProductCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProductCreateWithoutRelationsInput', List['ProductCreateWithoutRelationsInput']]
    connect: Union['ProductWhereUniqueInput', List['ProductWhereUniqueInput']]
    connect_or_create: Union['ProductConnectOrCreateWithoutRelationsInput', List['ProductConnectOrCreateWithoutRelationsInput']]

_ProductWhereUnique_id_Input = TypedDict(
    '_ProductWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ProductWhereUniqueInput = _ProductWhereUnique_id_Input


class ProductUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    name: _str
    description: Optional[_str]
    unit: _str
    unit_price: Union[AtomicIntInput, _int]
    lineitem_ids: 'types.StringListUpdate'
    lineitems: 'LineItemUpdateManyWithoutRelationsInput'


class ProductUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    name: _str
    description: Optional[_str]
    unit: _str
    unit_price: Union[AtomicIntInput, _int]
    lineitem_ids: 'types.StringListUpdate'


class ProductUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProductCreateWithoutRelationsInput']
    connect: List['ProductWhereUniqueInput']
    connect_or_create: List['ProductConnectOrCreateWithoutRelationsInput']
    set: List['ProductWhereUniqueInput']
    disconnect: List['ProductWhereUniqueInput']
    delete: List['ProductWhereUniqueInput']

    # TODO
    # update: List['ProductUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProductUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProductScalarWhereInput']
    # upsert: List['ProductUpserteWithWhereUniqueWithoutRelationsInput']


class ProductUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProductCreateWithoutRelationsInput'
    connect: 'ProductWhereUniqueInput'
    connect_or_create: 'ProductConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProductUpdateInput'
    # upsert: 'ProductUpsertWithoutRelationsInput'


class ProductUpsertInput(TypedDict):
    create: 'ProductCreateInput'
    update: 'ProductUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Product_id_OrderByInput = TypedDict(
    '_Product_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Product_created_at_OrderByInput = TypedDict(
    '_Product_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Product_updated_at_OrderByInput = TypedDict(
    '_Product_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_Product_name_OrderByInput = TypedDict(
    '_Product_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Product_description_OrderByInput = TypedDict(
    '_Product_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Product_unit_OrderByInput = TypedDict(
    '_Product_unit_OrderByInput',
    {
        'unit': 'SortOrder',
    },
    total=True
)

_Product_unit_price_OrderByInput = TypedDict(
    '_Product_unit_price_OrderByInput',
    {
        'unit_price': 'SortOrder',
    },
    total=True
)

_Product_lineitem_ids_OrderByInput = TypedDict(
    '_Product_lineitem_ids_OrderByInput',
    {
        'lineitem_ids': 'SortOrder',
    },
    total=True
)

ProductOrderByInput = Union[
    '_Product_id_OrderByInput',
    '_Product_created_at_OrderByInput',
    '_Product_updated_at_OrderByInput',
    '_Product_name_OrderByInput',
    '_Product_description_OrderByInput',
    '_Product_unit_OrderByInput',
    '_Product_unit_price_OrderByInput',
    '_Product_lineitem_ids_OrderByInput',
]



# recursive Product types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ProductRelationFilter = TypedDict(
    'ProductRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ProductListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ProductInclude(TypedDict, total=False):
    """Product relational arguments"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromProduct']


    

class AssociateIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive1']
    sales_clients: Union[bool, 'FindManyClientArgsFromProductRecursive1']
    sales_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive1']
    tech_clients: Union[bool, 'FindManyClientArgsFromProductRecursive1']
    tech_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive1']


class AssociateIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive2']
    sales_clients: Union[bool, 'FindManyClientArgsFromProductRecursive2']
    sales_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive2']
    tech_clients: Union[bool, 'FindManyClientArgsFromProductRecursive2']
    tech_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive2']


class AssociateIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive3']
    sales_clients: Union[bool, 'FindManyClientArgsFromProductRecursive3']
    sales_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive3']
    tech_clients: Union[bool, 'FindManyClientArgsFromProductRecursive3']
    tech_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive3']


class AssociateIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive4']
    sales_clients: Union[bool, 'FindManyClientArgsFromProductRecursive4']
    sales_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive4']
    tech_clients: Union[bool, 'FindManyClientArgsFromProductRecursive4']
    tech_orders: Union[bool, 'FindManyOrderArgsFromProductRecursive4']


class AssociateIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class AssociateArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'AssociateIncludeFromAssociateRecursive1'


class AssociateArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'AssociateIncludeFromAssociateRecursive2'


class AssociateArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'AssociateIncludeFromAssociateRecursive3'


class AssociateArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'AssociateIncludeFromAssociateRecursive4'


class AssociateArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyAssociateArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive1'


class FindManyAssociateArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive2'


class FindManyAssociateArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive3'


class FindManyAssociateArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive4'


class FindManyAssociateArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    
    

class ClientIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive1']


class ClientIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive2']


class ClientIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive3']


class ClientIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive4']


class ClientIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class ClientArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ClientIncludeFromClientRecursive1'


class ClientArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ClientIncludeFromClientRecursive2'


class ClientArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ClientIncludeFromClientRecursive3'


class ClientArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ClientIncludeFromClientRecursive4'


class ClientArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyClientArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive1'


class FindManyClientArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive2'


class FindManyClientArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive3'


class FindManyClientArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive4'


class FindManyClientArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    
    

class ProductIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromProductRecursive1']


class ProductIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromProductRecursive2']


class ProductIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromProductRecursive3']


class ProductIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromProductRecursive4']


class ProductIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class ProductArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyProductArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class LineItemIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    product: Union[bool, 'ProductArgsFromProductRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive1']


class LineItemIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    product: Union[bool, 'ProductArgsFromProductRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive2']


class LineItemIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    product: Union[bool, 'ProductArgsFromProductRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive3']


class LineItemIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    product: Union[bool, 'ProductArgsFromProductRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromProductRecursive4']


class LineItemIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class LineItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'LineItemIncludeFromLineItemRecursive1'


class LineItemArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'LineItemIncludeFromLineItemRecursive2'


class LineItemArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'LineItemIncludeFromLineItemRecursive3'


class LineItemArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'LineItemIncludeFromLineItemRecursive4'


class LineItemArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyLineItemArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive1'


class FindManyLineItemArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive2'


class FindManyLineItemArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive3'


class FindManyLineItemArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive4'


class FindManyLineItemArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    
    

class OrderIncludeFromProduct(TypedDict, total=False):
    """Relational arguments for Product"""
    audited_by: Union[bool, 'AssociateArgsFromProductRecursive1']
    client: Union[bool, 'ClientArgsFromProductRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive1']
    lineitems: Union[bool, 'FindManyLineItemArgsFromProductRecursive1']


class OrderIncludeFromProductRecursive1(TypedDict, total=False):
    """Relational arguments for Product"""
    audited_by: Union[bool, 'AssociateArgsFromProductRecursive2']
    client: Union[bool, 'ClientArgsFromProductRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive2']
    lineitems: Union[bool, 'FindManyLineItemArgsFromProductRecursive2']


class OrderIncludeFromProductRecursive2(TypedDict, total=False):
    """Relational arguments for Product"""
    audited_by: Union[bool, 'AssociateArgsFromProductRecursive3']
    client: Union[bool, 'ClientArgsFromProductRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive3']
    lineitems: Union[bool, 'FindManyLineItemArgsFromProductRecursive3']


class OrderIncludeFromProductRecursive3(TypedDict, total=False):
    """Relational arguments for Product"""
    audited_by: Union[bool, 'AssociateArgsFromProductRecursive4']
    client: Union[bool, 'ClientArgsFromProductRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromProductRecursive4']
    lineitems: Union[bool, 'FindManyLineItemArgsFromProductRecursive4']


class OrderIncludeFromProductRecursive4(TypedDict, total=False):
    """Relational arguments for Product"""

    

class OrderArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    
    

class FindManyOrderArgsFromProduct(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromProductRecursive1(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromProductRecursive2(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromProductRecursive3(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromProductRecursive4(TypedDict, total=False):
    """Arguments for Product"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    


FindManyProductArgs = FindManyProductArgsFromProduct
FindFirstProductArgs = FindManyProductArgsFromProduct


    

class ProductWhereInput(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    unit: Union[_str, 'types.StringFilter']
    unit_price: Union[_int, 'types.IntFilter']
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInputRecursive1', List['ProductWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInputRecursive1']
    OR: List['ProductWhereInputRecursive1']
    NOT: List['ProductWhereInputRecursive1']


class ProductWhereInputRecursive1(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    unit: Union[_str, 'types.StringFilter']
    unit_price: Union[_int, 'types.IntFilter']
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInputRecursive2', List['ProductWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInputRecursive2']
    OR: List['ProductWhereInputRecursive2']
    NOT: List['ProductWhereInputRecursive2']


class ProductWhereInputRecursive2(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    unit: Union[_str, 'types.StringFilter']
    unit_price: Union[_int, 'types.IntFilter']
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInputRecursive3', List['ProductWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInputRecursive3']
    OR: List['ProductWhereInputRecursive3']
    NOT: List['ProductWhereInputRecursive3']


class ProductWhereInputRecursive3(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    unit: Union[_str, 'types.StringFilter']
    unit_price: Union[_int, 'types.IntFilter']
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'

    # should be noted that AND and NOT should be Union['ProductWhereInputRecursive4', List['ProductWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ProductWhereInputRecursive4']
    OR: List['ProductWhereInputRecursive4']
    NOT: List['ProductWhereInputRecursive4']


class ProductWhereInputRecursive4(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    unit: Union[_str, 'types.StringFilter']
    unit_price: Union[_int, 'types.IntFilter']
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'



# aggregate Product types


    

class ProductScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    unit: Union[_str, 'types.StringWithAggregatesFilter']
    unit_price: Union[_int, 'types.IntWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInputRecursive1']
    OR: List['ProductScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ProductScalarWhereWithAggregatesInputRecursive1']


class ProductScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    unit: Union[_str, 'types.StringWithAggregatesFilter']
    unit_price: Union[_int, 'types.IntWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInputRecursive2']
    OR: List['ProductScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ProductScalarWhereWithAggregatesInputRecursive2']


class ProductScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    unit: Union[_str, 'types.StringWithAggregatesFilter']
    unit_price: Union[_int, 'types.IntWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInputRecursive3']
    OR: List['ProductScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ProductScalarWhereWithAggregatesInputRecursive3']


class ProductScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    unit: Union[_str, 'types.StringWithAggregatesFilter']
    unit_price: Union[_int, 'types.IntWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ProductScalarWhereWithAggregatesInputRecursive4']
    OR: List['ProductScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ProductScalarWhereWithAggregatesInputRecursive4']


class ProductScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Product arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    unit: Union[_str, 'types.StringWithAggregatesFilter']
    unit_price: Union[_int, 'types.IntWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']



class ProductGroupByOutput(TypedDict, total=False):
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    name: _str
    description: _str
    unit: _str
    unit_price: _int
    lineitem_ids: List[_str]
    _sum: 'ProductSumAggregateOutput'
    _avg: 'ProductAvgAggregateOutput'
    _min: 'ProductMinAggregateOutput'
    _max: 'ProductMaxAggregateOutput'
    _count: 'ProductCountAggregateOutput'


class ProductAvgAggregateOutput(TypedDict, total=False):
    """Product output for aggregating averages"""
    unit_price: float


class ProductSumAggregateOutput(TypedDict, total=False):
    """Product output for aggregating sums"""
    unit_price: _int


class ProductScalarAggregateOutput(TypedDict, total=False):
    """Product output including scalar fields"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    name: _str
    description: _str
    unit: _str
    unit_price: _int
    lineitem_ids: List[_str]


ProductMinAggregateOutput = ProductScalarAggregateOutput
ProductMaxAggregateOutput = ProductScalarAggregateOutput


class ProductMaxAggregateInput(TypedDict, total=False):
    """Product input for aggregating by max"""
    id: bool
    created_at: bool
    updated_at: bool
    name: bool
    description: bool
    unit: bool
    unit_price: bool
    lineitem_ids: bool


class ProductMinAggregateInput(TypedDict, total=False):
    """Product input for aggregating by min"""
    id: bool
    created_at: bool
    updated_at: bool
    name: bool
    description: bool
    unit: bool
    unit_price: bool
    lineitem_ids: bool


class ProductNumberAggregateInput(TypedDict, total=False):
    """Product input for aggregating numbers"""
    unit_price: bool


ProductAvgAggregateInput = ProductNumberAggregateInput
ProductSumAggregateInput = ProductNumberAggregateInput


ProductCountAggregateInput = TypedDict(
    'ProductCountAggregateInput',
    {
        'id': bool,
        'created_at': bool,
        'updated_at': bool,
        'name': bool,
        'description': bool,
        'unit': bool,
        'unit_price': bool,
        'lineitem_ids': bool,
        '_all': bool,
    },
    total=False,
)

ProductCountAggregateOutput = TypedDict(
    'ProductCountAggregateOutput',
    {
        'id': int,
        'created_at': int,
        'updated_at': int,
        'name': int,
        'description': int,
        'unit': int,
        'unit_price': int,
        'lineitem_ids': int,
        '_all': int,
    },
    total=False,
)


ProductKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'name',
    'description',
    'unit',
    'unit_price',
    'lineitem_ids',
    'lineitems',
]
ProductScalarFieldKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'name',
    'description',
    'unit',
    'unit_price',
    'lineitem_ids',
]
ProductScalarFieldKeysT = TypeVar('ProductScalarFieldKeysT', bound=ProductScalarFieldKeys)

ProductRelationalFieldKeys = Literal[
        'lineitems',
    ]

# LineItem types

class LineItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the LineItem create method"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    product_id: _str
    product: 'ProductCreateNestedWithoutRelationsInput'
    order_ids: List[_str]
    orders: 'OrderCreateManyNestedWithoutRelationsInput'


class LineItemCreateInput(LineItemOptionalCreateInput):
    """Required arguments to the LineItem create method"""
    qty: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class LineItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the LineItem create method, without relations"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    product_id: _str
    order_ids: List[_str]


class LineItemCreateWithoutRelationsInput(LineItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the LineItem create method, without relations"""
    qty: _int

class LineItemConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'LineItemCreateWithoutRelationsInput'
    where: 'LineItemWhereUniqueInput'

class LineItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'LineItemCreateWithoutRelationsInput'
    connect: 'LineItemWhereUniqueInput'
    connect_or_create: 'LineItemConnectOrCreateWithoutRelationsInput'


class LineItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['LineItemCreateWithoutRelationsInput', List['LineItemCreateWithoutRelationsInput']]
    connect: Union['LineItemWhereUniqueInput', List['LineItemWhereUniqueInput']]
    connect_or_create: Union['LineItemConnectOrCreateWithoutRelationsInput', List['LineItemConnectOrCreateWithoutRelationsInput']]

_LineItemWhereUnique_id_Input = TypedDict(
    '_LineItemWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

LineItemWhereUniqueInput = _LineItemWhereUnique_id_Input


class LineItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    qty: Union[AtomicIntInput, _int]
    product: 'ProductUpdateOneWithoutRelationsInput'
    orders: 'OrderUpdateManyWithoutRelationsInput'


class LineItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    qty: Union[AtomicIntInput, _int]


class LineItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['LineItemCreateWithoutRelationsInput']
    connect: List['LineItemWhereUniqueInput']
    connect_or_create: List['LineItemConnectOrCreateWithoutRelationsInput']
    set: List['LineItemWhereUniqueInput']
    disconnect: List['LineItemWhereUniqueInput']
    delete: List['LineItemWhereUniqueInput']

    # TODO
    # update: List['LineItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['LineItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['LineItemScalarWhereInput']
    # upsert: List['LineItemUpserteWithWhereUniqueWithoutRelationsInput']


class LineItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'LineItemCreateWithoutRelationsInput'
    connect: 'LineItemWhereUniqueInput'
    connect_or_create: 'LineItemConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'LineItemUpdateInput'
    # upsert: 'LineItemUpsertWithoutRelationsInput'


class LineItemUpsertInput(TypedDict):
    create: 'LineItemCreateInput'
    update: 'LineItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_LineItem_id_OrderByInput = TypedDict(
    '_LineItem_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_LineItem_created_at_OrderByInput = TypedDict(
    '_LineItem_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_LineItem_updated_at_OrderByInput = TypedDict(
    '_LineItem_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_LineItem_qty_OrderByInput = TypedDict(
    '_LineItem_qty_OrderByInput',
    {
        'qty': 'SortOrder',
    },
    total=True
)

_LineItem_product_id_OrderByInput = TypedDict(
    '_LineItem_product_id_OrderByInput',
    {
        'product_id': 'SortOrder',
    },
    total=True
)

_LineItem_order_ids_OrderByInput = TypedDict(
    '_LineItem_order_ids_OrderByInput',
    {
        'order_ids': 'SortOrder',
    },
    total=True
)

LineItemOrderByInput = Union[
    '_LineItem_id_OrderByInput',
    '_LineItem_created_at_OrderByInput',
    '_LineItem_updated_at_OrderByInput',
    '_LineItem_qty_OrderByInput',
    '_LineItem_product_id_OrderByInput',
    '_LineItem_order_ids_OrderByInput',
]



# recursive LineItem types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

LineItemRelationFilter = TypedDict(
    'LineItemRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class LineItemListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class LineItemInclude(TypedDict, total=False):
    """LineItem relational arguments"""
    product: Union[bool, 'ProductArgsFromLineItem']
    orders: Union[bool, 'FindManyOrderArgsFromLineItem']


    

class AssociateIncludeFromLineItem(TypedDict, total=False):
    """Relational arguments for LineItem"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive1']
    sales_clients: Union[bool, 'FindManyClientArgsFromLineItemRecursive1']
    sales_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive1']
    tech_clients: Union[bool, 'FindManyClientArgsFromLineItemRecursive1']
    tech_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive1']


class AssociateIncludeFromLineItemRecursive1(TypedDict, total=False):
    """Relational arguments for LineItem"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive2']
    sales_clients: Union[bool, 'FindManyClientArgsFromLineItemRecursive2']
    sales_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive2']
    tech_clients: Union[bool, 'FindManyClientArgsFromLineItemRecursive2']
    tech_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive2']


class AssociateIncludeFromLineItemRecursive2(TypedDict, total=False):
    """Relational arguments for LineItem"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive3']
    sales_clients: Union[bool, 'FindManyClientArgsFromLineItemRecursive3']
    sales_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive3']
    tech_clients: Union[bool, 'FindManyClientArgsFromLineItemRecursive3']
    tech_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive3']


class AssociateIncludeFromLineItemRecursive3(TypedDict, total=False):
    """Relational arguments for LineItem"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive4']
    sales_clients: Union[bool, 'FindManyClientArgsFromLineItemRecursive4']
    sales_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive4']
    tech_clients: Union[bool, 'FindManyClientArgsFromLineItemRecursive4']
    tech_orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive4']


class AssociateIncludeFromLineItemRecursive4(TypedDict, total=False):
    """Relational arguments for LineItem"""

    

class AssociateArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'AssociateIncludeFromAssociateRecursive1'


class AssociateArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'AssociateIncludeFromAssociateRecursive2'


class AssociateArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'AssociateIncludeFromAssociateRecursive3'


class AssociateArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'AssociateIncludeFromAssociateRecursive4'


class AssociateArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    
    

class FindManyAssociateArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive1'


class FindManyAssociateArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive2'


class FindManyAssociateArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive3'


class FindManyAssociateArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive4'


class FindManyAssociateArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    
    

class ClientIncludeFromLineItem(TypedDict, total=False):
    """Relational arguments for LineItem"""
    orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive1']


class ClientIncludeFromLineItemRecursive1(TypedDict, total=False):
    """Relational arguments for LineItem"""
    orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive2']


class ClientIncludeFromLineItemRecursive2(TypedDict, total=False):
    """Relational arguments for LineItem"""
    orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive3']


class ClientIncludeFromLineItemRecursive3(TypedDict, total=False):
    """Relational arguments for LineItem"""
    orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive4']


class ClientIncludeFromLineItemRecursive4(TypedDict, total=False):
    """Relational arguments for LineItem"""

    

class ClientArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'ClientIncludeFromClientRecursive1'


class ClientArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'ClientIncludeFromClientRecursive2'


class ClientArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'ClientIncludeFromClientRecursive3'


class ClientArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'ClientIncludeFromClientRecursive4'


class ClientArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    
    

class FindManyClientArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive1'


class FindManyClientArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive2'


class FindManyClientArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive3'


class FindManyClientArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive4'


class FindManyClientArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    
    

class ProductIncludeFromLineItem(TypedDict, total=False):
    """Relational arguments for LineItem"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromLineItemRecursive1']


class ProductIncludeFromLineItemRecursive1(TypedDict, total=False):
    """Relational arguments for LineItem"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromLineItemRecursive2']


class ProductIncludeFromLineItemRecursive2(TypedDict, total=False):
    """Relational arguments for LineItem"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromLineItemRecursive3']


class ProductIncludeFromLineItemRecursive3(TypedDict, total=False):
    """Relational arguments for LineItem"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromLineItemRecursive4']


class ProductIncludeFromLineItemRecursive4(TypedDict, total=False):
    """Relational arguments for LineItem"""

    

class ProductArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    
    

class FindManyProductArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class LineItemIncludeFromLineItem(TypedDict, total=False):
    """Relational arguments for LineItem"""
    product: Union[bool, 'ProductArgsFromLineItemRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive1']


class LineItemIncludeFromLineItemRecursive1(TypedDict, total=False):
    """Relational arguments for LineItem"""
    product: Union[bool, 'ProductArgsFromLineItemRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive2']


class LineItemIncludeFromLineItemRecursive2(TypedDict, total=False):
    """Relational arguments for LineItem"""
    product: Union[bool, 'ProductArgsFromLineItemRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive3']


class LineItemIncludeFromLineItemRecursive3(TypedDict, total=False):
    """Relational arguments for LineItem"""
    product: Union[bool, 'ProductArgsFromLineItemRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromLineItemRecursive4']


class LineItemIncludeFromLineItemRecursive4(TypedDict, total=False):
    """Relational arguments for LineItem"""

    

class LineItemArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'LineItemIncludeFromLineItemRecursive1'


class LineItemArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'LineItemIncludeFromLineItemRecursive2'


class LineItemArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'LineItemIncludeFromLineItemRecursive3'


class LineItemArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'LineItemIncludeFromLineItemRecursive4'


class LineItemArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    
    

class FindManyLineItemArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive1'


class FindManyLineItemArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive2'


class FindManyLineItemArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive3'


class FindManyLineItemArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive4'


class FindManyLineItemArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    
    

class OrderIncludeFromLineItem(TypedDict, total=False):
    """Relational arguments for LineItem"""
    audited_by: Union[bool, 'AssociateArgsFromLineItemRecursive1']
    client: Union[bool, 'ClientArgsFromLineItemRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive1']
    lineitems: Union[bool, 'FindManyLineItemArgsFromLineItemRecursive1']


class OrderIncludeFromLineItemRecursive1(TypedDict, total=False):
    """Relational arguments for LineItem"""
    audited_by: Union[bool, 'AssociateArgsFromLineItemRecursive2']
    client: Union[bool, 'ClientArgsFromLineItemRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive2']
    lineitems: Union[bool, 'FindManyLineItemArgsFromLineItemRecursive2']


class OrderIncludeFromLineItemRecursive2(TypedDict, total=False):
    """Relational arguments for LineItem"""
    audited_by: Union[bool, 'AssociateArgsFromLineItemRecursive3']
    client: Union[bool, 'ClientArgsFromLineItemRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive3']
    lineitems: Union[bool, 'FindManyLineItemArgsFromLineItemRecursive3']


class OrderIncludeFromLineItemRecursive3(TypedDict, total=False):
    """Relational arguments for LineItem"""
    audited_by: Union[bool, 'AssociateArgsFromLineItemRecursive4']
    client: Union[bool, 'ClientArgsFromLineItemRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromLineItemRecursive4']
    lineitems: Union[bool, 'FindManyLineItemArgsFromLineItemRecursive4']


class OrderIncludeFromLineItemRecursive4(TypedDict, total=False):
    """Relational arguments for LineItem"""

    

class OrderArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    
    

class FindManyOrderArgsFromLineItem(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromLineItemRecursive1(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromLineItemRecursive2(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromLineItemRecursive3(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromLineItemRecursive4(TypedDict, total=False):
    """Arguments for LineItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    


FindManyLineItemArgs = FindManyLineItemArgsFromLineItem
FindFirstLineItemArgs = FindManyLineItemArgsFromLineItem


    

class LineItemWhereInput(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    qty: Union[_int, 'types.IntFilter']
    product_id: Union[_str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['LineItemWhereInputRecursive1', List['LineItemWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['LineItemWhereInputRecursive1']
    OR: List['LineItemWhereInputRecursive1']
    NOT: List['LineItemWhereInputRecursive1']


class LineItemWhereInputRecursive1(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    qty: Union[_int, 'types.IntFilter']
    product_id: Union[_str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['LineItemWhereInputRecursive2', List['LineItemWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['LineItemWhereInputRecursive2']
    OR: List['LineItemWhereInputRecursive2']
    NOT: List['LineItemWhereInputRecursive2']


class LineItemWhereInputRecursive2(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    qty: Union[_int, 'types.IntFilter']
    product_id: Union[_str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['LineItemWhereInputRecursive3', List['LineItemWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['LineItemWhereInputRecursive3']
    OR: List['LineItemWhereInputRecursive3']
    NOT: List['LineItemWhereInputRecursive3']


class LineItemWhereInputRecursive3(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    qty: Union[_int, 'types.IntFilter']
    product_id: Union[_str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'

    # should be noted that AND and NOT should be Union['LineItemWhereInputRecursive4', List['LineItemWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['LineItemWhereInputRecursive4']
    OR: List['LineItemWhereInputRecursive4']
    NOT: List['LineItemWhereInputRecursive4']


class LineItemWhereInputRecursive4(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    qty: Union[_int, 'types.IntFilter']
    product_id: Union[_str, 'types.StringFilter']
    product: 'ProductRelationFilter'
    order_ids: 'types.StringListFilter'
    orders: 'OrderListRelationFilter'



# aggregate LineItem types


    

class LineItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    qty: Union[_int, 'types.IntWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LineItemScalarWhereWithAggregatesInputRecursive1']
    OR: List['LineItemScalarWhereWithAggregatesInputRecursive1']
    NOT: List['LineItemScalarWhereWithAggregatesInputRecursive1']


class LineItemScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    qty: Union[_int, 'types.IntWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LineItemScalarWhereWithAggregatesInputRecursive2']
    OR: List['LineItemScalarWhereWithAggregatesInputRecursive2']
    NOT: List['LineItemScalarWhereWithAggregatesInputRecursive2']


class LineItemScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    qty: Union[_int, 'types.IntWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LineItemScalarWhereWithAggregatesInputRecursive3']
    OR: List['LineItemScalarWhereWithAggregatesInputRecursive3']
    NOT: List['LineItemScalarWhereWithAggregatesInputRecursive3']


class LineItemScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    qty: Union[_int, 'types.IntWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LineItemScalarWhereWithAggregatesInputRecursive4']
    OR: List['LineItemScalarWhereWithAggregatesInputRecursive4']
    NOT: List['LineItemScalarWhereWithAggregatesInputRecursive4']


class LineItemScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """LineItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    qty: Union[_int, 'types.IntWithAggregatesFilter']
    product_id: Union[_str, 'types.StringWithAggregatesFilter']
    order_ids: Union[_str, 'types.StringWithAggregatesFilter']



class LineItemGroupByOutput(TypedDict, total=False):
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    qty: _int
    product_id: _str
    order_ids: List[_str]
    _sum: 'LineItemSumAggregateOutput'
    _avg: 'LineItemAvgAggregateOutput'
    _min: 'LineItemMinAggregateOutput'
    _max: 'LineItemMaxAggregateOutput'
    _count: 'LineItemCountAggregateOutput'


class LineItemAvgAggregateOutput(TypedDict, total=False):
    """LineItem output for aggregating averages"""
    qty: float


class LineItemSumAggregateOutput(TypedDict, total=False):
    """LineItem output for aggregating sums"""
    qty: _int


class LineItemScalarAggregateOutput(TypedDict, total=False):
    """LineItem output including scalar fields"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    qty: _int
    product_id: _str
    order_ids: List[_str]


LineItemMinAggregateOutput = LineItemScalarAggregateOutput
LineItemMaxAggregateOutput = LineItemScalarAggregateOutput


class LineItemMaxAggregateInput(TypedDict, total=False):
    """LineItem input for aggregating by max"""
    id: bool
    created_at: bool
    updated_at: bool
    qty: bool
    product_id: bool
    order_ids: bool


class LineItemMinAggregateInput(TypedDict, total=False):
    """LineItem input for aggregating by min"""
    id: bool
    created_at: bool
    updated_at: bool
    qty: bool
    product_id: bool
    order_ids: bool


class LineItemNumberAggregateInput(TypedDict, total=False):
    """LineItem input for aggregating numbers"""
    qty: bool


LineItemAvgAggregateInput = LineItemNumberAggregateInput
LineItemSumAggregateInput = LineItemNumberAggregateInput


LineItemCountAggregateInput = TypedDict(
    'LineItemCountAggregateInput',
    {
        'id': bool,
        'created_at': bool,
        'updated_at': bool,
        'qty': bool,
        'product_id': bool,
        'order_ids': bool,
        '_all': bool,
    },
    total=False,
)

LineItemCountAggregateOutput = TypedDict(
    'LineItemCountAggregateOutput',
    {
        'id': int,
        'created_at': int,
        'updated_at': int,
        'qty': int,
        'product_id': int,
        'order_ids': int,
        '_all': int,
    },
    total=False,
)


LineItemKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'qty',
    'product_id',
    'product',
    'order_ids',
    'orders',
]
LineItemScalarFieldKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'qty',
    'product_id',
    'order_ids',
]
LineItemScalarFieldKeysT = TypeVar('LineItemScalarFieldKeysT', bound=LineItemScalarFieldKeys)

LineItemRelationalFieldKeys = Literal[
        'product',
        'orders',
    ]

# Order types

class OrderOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Order create method"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    sales_commission: Optional[_int]
    tech_commission: Optional[_int]
    company_cut: Optional[_int]
    stripe_payment_intent_id: Optional[_str]
    stripe_invoice_id: Optional[_str]
    stripe_status: Optional[_str]
    audited_at: Optional[datetime.datetime]
    audit_notes: Optional[_str]
    audited_by_id: Optional[_str]
    audited_by: 'AssociateCreateNestedWithoutRelationsInput'
    client_id: _str
    client: 'ClientCreateNestedWithoutRelationsInput'
    sales_associate_ids: List[_str]
    sales_associates: 'AssociateCreateManyNestedWithoutRelationsInput'
    tech_associate_ids: List[_str]
    tech_associates: 'AssociateCreateManyNestedWithoutRelationsInput'
    lineitem_ids: List[_str]
    lineitems: 'LineItemCreateManyNestedWithoutRelationsInput'


class OrderCreateInput(OrderOptionalCreateInput):
    """Required arguments to the Order create method"""
    invoice_number: _str
    status: _str
    sales_tax: _int
    total_due: _int
    transaction_fee: _int
    revenue: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OrderOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Order create method, without relations"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    sales_commission: Optional[_int]
    tech_commission: Optional[_int]
    company_cut: Optional[_int]
    stripe_payment_intent_id: Optional[_str]
    stripe_invoice_id: Optional[_str]
    stripe_status: Optional[_str]
    audited_at: Optional[datetime.datetime]
    audit_notes: Optional[_str]
    audited_by_id: Optional[_str]
    client_id: _str
    sales_associate_ids: List[_str]
    tech_associate_ids: List[_str]
    lineitem_ids: List[_str]


class OrderCreateWithoutRelationsInput(OrderOptionalCreateWithoutRelationsInput):
    """Required arguments to the Order create method, without relations"""
    invoice_number: _str
    status: _str
    sales_tax: _int
    total_due: _int
    transaction_fee: _int
    revenue: _int

class OrderConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'OrderCreateWithoutRelationsInput'
    where: 'OrderWhereUniqueInput'

class OrderCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderCreateWithoutRelationsInput'
    connect: 'OrderWhereUniqueInput'
    connect_or_create: 'OrderConnectOrCreateWithoutRelationsInput'


class OrderCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OrderCreateWithoutRelationsInput', List['OrderCreateWithoutRelationsInput']]
    connect: Union['OrderWhereUniqueInput', List['OrderWhereUniqueInput']]
    connect_or_create: Union['OrderConnectOrCreateWithoutRelationsInput', List['OrderConnectOrCreateWithoutRelationsInput']]

_OrderWhereUnique_id_Input = TypedDict(
    '_OrderWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

OrderWhereUniqueInput = _OrderWhereUnique_id_Input


class OrderUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    invoice_number: _str
    status: _str
    sales_tax: Union[AtomicIntInput, _int]
    total_due: Union[AtomicIntInput, _int]
    transaction_fee: Union[AtomicIntInput, _int]
    revenue: Union[AtomicIntInput, _int]
    sales_commission: Optional[Union[AtomicIntInput, _int]]
    tech_commission: Optional[Union[AtomicIntInput, _int]]
    company_cut: Optional[Union[AtomicIntInput, _int]]
    stripe_payment_intent_id: Optional[_str]
    stripe_invoice_id: Optional[_str]
    stripe_status: Optional[_str]
    audited_at: Optional[datetime.datetime]
    audit_notes: Optional[_str]
    audited_by: 'AssociateUpdateOneWithoutRelationsInput'
    client: 'ClientUpdateOneWithoutRelationsInput'
    sales_associates: 'AssociateUpdateManyWithoutRelationsInput'
    tech_associates: 'AssociateUpdateManyWithoutRelationsInput'
    lineitems: 'LineItemUpdateManyWithoutRelationsInput'


class OrderUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    invoice_number: _str
    status: _str
    sales_tax: Union[AtomicIntInput, _int]
    total_due: Union[AtomicIntInput, _int]
    transaction_fee: Union[AtomicIntInput, _int]
    revenue: Union[AtomicIntInput, _int]
    sales_commission: Optional[Union[AtomicIntInput, _int]]
    tech_commission: Optional[Union[AtomicIntInput, _int]]
    company_cut: Optional[Union[AtomicIntInput, _int]]
    stripe_payment_intent_id: Optional[_str]
    stripe_invoice_id: Optional[_str]
    stripe_status: Optional[_str]
    audited_at: Optional[datetime.datetime]
    audit_notes: Optional[_str]


class OrderUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OrderCreateWithoutRelationsInput']
    connect: List['OrderWhereUniqueInput']
    connect_or_create: List['OrderConnectOrCreateWithoutRelationsInput']
    set: List['OrderWhereUniqueInput']
    disconnect: List['OrderWhereUniqueInput']
    delete: List['OrderWhereUniqueInput']

    # TODO
    # update: List['OrderUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OrderUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OrderScalarWhereInput']
    # upsert: List['OrderUpserteWithWhereUniqueWithoutRelationsInput']


class OrderUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderCreateWithoutRelationsInput'
    connect: 'OrderWhereUniqueInput'
    connect_or_create: 'OrderConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OrderUpdateInput'
    # upsert: 'OrderUpsertWithoutRelationsInput'


class OrderUpsertInput(TypedDict):
    create: 'OrderCreateInput'
    update: 'OrderUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Order_id_OrderByInput = TypedDict(
    '_Order_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Order_created_at_OrderByInput = TypedDict(
    '_Order_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Order_updated_at_OrderByInput = TypedDict(
    '_Order_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_Order_invoice_number_OrderByInput = TypedDict(
    '_Order_invoice_number_OrderByInput',
    {
        'invoice_number': 'SortOrder',
    },
    total=True
)

_Order_status_OrderByInput = TypedDict(
    '_Order_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Order_sales_tax_OrderByInput = TypedDict(
    '_Order_sales_tax_OrderByInput',
    {
        'sales_tax': 'SortOrder',
    },
    total=True
)

_Order_total_due_OrderByInput = TypedDict(
    '_Order_total_due_OrderByInput',
    {
        'total_due': 'SortOrder',
    },
    total=True
)

_Order_transaction_fee_OrderByInput = TypedDict(
    '_Order_transaction_fee_OrderByInput',
    {
        'transaction_fee': 'SortOrder',
    },
    total=True
)

_Order_revenue_OrderByInput = TypedDict(
    '_Order_revenue_OrderByInput',
    {
        'revenue': 'SortOrder',
    },
    total=True
)

_Order_sales_commission_OrderByInput = TypedDict(
    '_Order_sales_commission_OrderByInput',
    {
        'sales_commission': 'SortOrder',
    },
    total=True
)

_Order_tech_commission_OrderByInput = TypedDict(
    '_Order_tech_commission_OrderByInput',
    {
        'tech_commission': 'SortOrder',
    },
    total=True
)

_Order_company_cut_OrderByInput = TypedDict(
    '_Order_company_cut_OrderByInput',
    {
        'company_cut': 'SortOrder',
    },
    total=True
)

_Order_stripe_payment_intent_id_OrderByInput = TypedDict(
    '_Order_stripe_payment_intent_id_OrderByInput',
    {
        'stripe_payment_intent_id': 'SortOrder',
    },
    total=True
)

_Order_stripe_invoice_id_OrderByInput = TypedDict(
    '_Order_stripe_invoice_id_OrderByInput',
    {
        'stripe_invoice_id': 'SortOrder',
    },
    total=True
)

_Order_stripe_status_OrderByInput = TypedDict(
    '_Order_stripe_status_OrderByInput',
    {
        'stripe_status': 'SortOrder',
    },
    total=True
)

_Order_audited_at_OrderByInput = TypedDict(
    '_Order_audited_at_OrderByInput',
    {
        'audited_at': 'SortOrder',
    },
    total=True
)

_Order_audit_notes_OrderByInput = TypedDict(
    '_Order_audit_notes_OrderByInput',
    {
        'audit_notes': 'SortOrder',
    },
    total=True
)

_Order_audited_by_id_OrderByInput = TypedDict(
    '_Order_audited_by_id_OrderByInput',
    {
        'audited_by_id': 'SortOrder',
    },
    total=True
)

_Order_client_id_OrderByInput = TypedDict(
    '_Order_client_id_OrderByInput',
    {
        'client_id': 'SortOrder',
    },
    total=True
)

_Order_sales_associate_ids_OrderByInput = TypedDict(
    '_Order_sales_associate_ids_OrderByInput',
    {
        'sales_associate_ids': 'SortOrder',
    },
    total=True
)

_Order_tech_associate_ids_OrderByInput = TypedDict(
    '_Order_tech_associate_ids_OrderByInput',
    {
        'tech_associate_ids': 'SortOrder',
    },
    total=True
)

_Order_lineitem_ids_OrderByInput = TypedDict(
    '_Order_lineitem_ids_OrderByInput',
    {
        'lineitem_ids': 'SortOrder',
    },
    total=True
)

OrderOrderByInput = Union[
    '_Order_id_OrderByInput',
    '_Order_created_at_OrderByInput',
    '_Order_updated_at_OrderByInput',
    '_Order_invoice_number_OrderByInput',
    '_Order_status_OrderByInput',
    '_Order_sales_tax_OrderByInput',
    '_Order_total_due_OrderByInput',
    '_Order_transaction_fee_OrderByInput',
    '_Order_revenue_OrderByInput',
    '_Order_sales_commission_OrderByInput',
    '_Order_tech_commission_OrderByInput',
    '_Order_company_cut_OrderByInput',
    '_Order_stripe_payment_intent_id_OrderByInput',
    '_Order_stripe_invoice_id_OrderByInput',
    '_Order_stripe_status_OrderByInput',
    '_Order_audited_at_OrderByInput',
    '_Order_audit_notes_OrderByInput',
    '_Order_audited_by_id_OrderByInput',
    '_Order_client_id_OrderByInput',
    '_Order_sales_associate_ids_OrderByInput',
    '_Order_tech_associate_ids_OrderByInput',
    '_Order_lineitem_ids_OrderByInput',
]



# recursive Order types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

OrderRelationFilter = TypedDict(
    'OrderRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class OrderListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class OrderInclude(TypedDict, total=False):
    """Order relational arguments"""
    audited_by: Union[bool, 'AssociateArgsFromOrder']
    client: Union[bool, 'ClientArgsFromOrder']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrder']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrder']
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrder']


    

class AssociateIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive1']
    sales_clients: Union[bool, 'FindManyClientArgsFromOrderRecursive1']
    sales_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive1']
    tech_clients: Union[bool, 'FindManyClientArgsFromOrderRecursive1']
    tech_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive1']


class AssociateIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive2']
    sales_clients: Union[bool, 'FindManyClientArgsFromOrderRecursive2']
    sales_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive2']
    tech_clients: Union[bool, 'FindManyClientArgsFromOrderRecursive2']
    tech_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive2']


class AssociateIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive3']
    sales_clients: Union[bool, 'FindManyClientArgsFromOrderRecursive3']
    sales_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive3']
    tech_clients: Union[bool, 'FindManyClientArgsFromOrderRecursive3']
    tech_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive3']


class AssociateIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    audited_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive4']
    sales_clients: Union[bool, 'FindManyClientArgsFromOrderRecursive4']
    sales_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive4']
    tech_clients: Union[bool, 'FindManyClientArgsFromOrderRecursive4']
    tech_orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive4']


class AssociateIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class AssociateArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'AssociateIncludeFromAssociateRecursive1'


class AssociateArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'AssociateIncludeFromAssociateRecursive2'


class AssociateArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'AssociateIncludeFromAssociateRecursive3'


class AssociateArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'AssociateIncludeFromAssociateRecursive4'


class AssociateArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyAssociateArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive1'


class FindManyAssociateArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive2'


class FindManyAssociateArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive3'


class FindManyAssociateArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    include: 'AssociateIncludeFromAssociateRecursive4'


class FindManyAssociateArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['AssociateOrderByInput', List['AssociateOrderByInput']]
    where: 'AssociateWhereInput'
    cursor: 'AssociateWhereUniqueInput'
    distinct: List['AssociateScalarFieldKeys']
    
    

class ClientIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive1']


class ClientIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive2']


class ClientIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive3']


class ClientIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive4']


class ClientIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class ClientArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ClientIncludeFromClientRecursive1'


class ClientArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ClientIncludeFromClientRecursive2'


class ClientArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ClientIncludeFromClientRecursive3'


class ClientArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ClientIncludeFromClientRecursive4'


class ClientArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyClientArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive1'


class FindManyClientArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive2'


class FindManyClientArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive3'


class FindManyClientArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    include: 'ClientIncludeFromClientRecursive4'


class FindManyClientArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ClientOrderByInput', List['ClientOrderByInput']]
    where: 'ClientWhereInput'
    cursor: 'ClientWhereUniqueInput'
    distinct: List['ClientScalarFieldKeys']
    
    

class ProductIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrderRecursive1']


class ProductIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrderRecursive2']


class ProductIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrderRecursive3']


class ProductIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrderRecursive4']


class ProductIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class ProductArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ProductIncludeFromProductRecursive1'


class ProductArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ProductIncludeFromProductRecursive2'


class ProductArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ProductIncludeFromProductRecursive3'


class ProductArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ProductIncludeFromProductRecursive4'


class ProductArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyProductArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive1'


class FindManyProductArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive2'


class FindManyProductArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive3'


class FindManyProductArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    include: 'ProductIncludeFromProductRecursive4'


class FindManyProductArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ProductOrderByInput', List['ProductOrderByInput']]
    where: 'ProductWhereInput'
    cursor: 'ProductWhereUniqueInput'
    distinct: List['ProductScalarFieldKeys']
    
    

class LineItemIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    product: Union[bool, 'ProductArgsFromOrderRecursive1']
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive1']


class LineItemIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    product: Union[bool, 'ProductArgsFromOrderRecursive2']
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive2']


class LineItemIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    product: Union[bool, 'ProductArgsFromOrderRecursive3']
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive3']


class LineItemIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    product: Union[bool, 'ProductArgsFromOrderRecursive4']
    orders: Union[bool, 'FindManyOrderArgsFromOrderRecursive4']


class LineItemIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class LineItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'LineItemIncludeFromLineItemRecursive1'


class LineItemArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'LineItemIncludeFromLineItemRecursive2'


class LineItemArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'LineItemIncludeFromLineItemRecursive3'


class LineItemArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'LineItemIncludeFromLineItemRecursive4'


class LineItemArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyLineItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive1'


class FindManyLineItemArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive2'


class FindManyLineItemArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive3'


class FindManyLineItemArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    include: 'LineItemIncludeFromLineItemRecursive4'


class FindManyLineItemArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['LineItemOrderByInput', List['LineItemOrderByInput']]
    where: 'LineItemWhereInput'
    cursor: 'LineItemWhereUniqueInput'
    distinct: List['LineItemScalarFieldKeys']
    
    

class OrderIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    audited_by: Union[bool, 'AssociateArgsFromOrderRecursive1']
    client: Union[bool, 'ClientArgsFromOrderRecursive1']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive1']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive1']
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrderRecursive1']


class OrderIncludeFromOrderRecursive1(TypedDict, total=False):
    """Relational arguments for Order"""
    audited_by: Union[bool, 'AssociateArgsFromOrderRecursive2']
    client: Union[bool, 'ClientArgsFromOrderRecursive2']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive2']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive2']
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrderRecursive2']


class OrderIncludeFromOrderRecursive2(TypedDict, total=False):
    """Relational arguments for Order"""
    audited_by: Union[bool, 'AssociateArgsFromOrderRecursive3']
    client: Union[bool, 'ClientArgsFromOrderRecursive3']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive3']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive3']
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrderRecursive3']


class OrderIncludeFromOrderRecursive3(TypedDict, total=False):
    """Relational arguments for Order"""
    audited_by: Union[bool, 'AssociateArgsFromOrderRecursive4']
    client: Union[bool, 'ClientArgsFromOrderRecursive4']
    sales_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive4']
    tech_associates: Union[bool, 'FindManyAssociateArgsFromOrderRecursive4']
    lineitems: Union[bool, 'FindManyLineItemArgsFromOrderRecursive4']


class OrderIncludeFromOrderRecursive4(TypedDict, total=False):
    """Relational arguments for Order"""

    

class OrderArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrderRecursive1'


class OrderArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrderRecursive2'


class OrderArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrderRecursive3'


class OrderArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrderRecursive4'


class OrderArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    
    

class FindManyOrderArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive1'


class FindManyOrderArgsFromOrderRecursive1(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive2'


class FindManyOrderArgsFromOrderRecursive2(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive3'


class FindManyOrderArgsFromOrderRecursive3(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrderRecursive4'


class FindManyOrderArgsFromOrderRecursive4(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    


FindManyOrderArgs = FindManyOrderArgsFromOrder
FindFirstOrderArgs = FindManyOrderArgsFromOrder


    

class OrderWhereInput(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    invoice_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    sales_tax: Union[_int, 'types.IntFilter']
    total_due: Union[_int, 'types.IntFilter']
    transaction_fee: Union[_int, 'types.IntFilter']
    revenue: Union[_int, 'types.IntFilter']
    sales_commission: Union[None, _int, 'types.IntFilter']
    tech_commission: Union[None, _int, 'types.IntFilter']
    company_cut: Union[None, _int, 'types.IntFilter']
    stripe_payment_intent_id: Union[None, _str, 'types.StringFilter']
    stripe_invoice_id: Union[None, _str, 'types.StringFilter']
    stripe_status: Union[None, _str, 'types.StringFilter']
    audited_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    audit_notes: Union[None, _str, 'types.StringFilter']
    audited_by_id: Union[None, _str, 'types.StringFilter']
    audited_by: 'AssociateRelationFilter'
    client_id: Union[_str, 'types.StringFilter']
    client: 'ClientRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'

    # should be noted that AND and NOT should be Union['OrderWhereInputRecursive1', List['OrderWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInputRecursive1']
    OR: List['OrderWhereInputRecursive1']
    NOT: List['OrderWhereInputRecursive1']


class OrderWhereInputRecursive1(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    invoice_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    sales_tax: Union[_int, 'types.IntFilter']
    total_due: Union[_int, 'types.IntFilter']
    transaction_fee: Union[_int, 'types.IntFilter']
    revenue: Union[_int, 'types.IntFilter']
    sales_commission: Union[None, _int, 'types.IntFilter']
    tech_commission: Union[None, _int, 'types.IntFilter']
    company_cut: Union[None, _int, 'types.IntFilter']
    stripe_payment_intent_id: Union[None, _str, 'types.StringFilter']
    stripe_invoice_id: Union[None, _str, 'types.StringFilter']
    stripe_status: Union[None, _str, 'types.StringFilter']
    audited_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    audit_notes: Union[None, _str, 'types.StringFilter']
    audited_by_id: Union[None, _str, 'types.StringFilter']
    audited_by: 'AssociateRelationFilter'
    client_id: Union[_str, 'types.StringFilter']
    client: 'ClientRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'

    # should be noted that AND and NOT should be Union['OrderWhereInputRecursive2', List['OrderWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInputRecursive2']
    OR: List['OrderWhereInputRecursive2']
    NOT: List['OrderWhereInputRecursive2']


class OrderWhereInputRecursive2(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    invoice_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    sales_tax: Union[_int, 'types.IntFilter']
    total_due: Union[_int, 'types.IntFilter']
    transaction_fee: Union[_int, 'types.IntFilter']
    revenue: Union[_int, 'types.IntFilter']
    sales_commission: Union[None, _int, 'types.IntFilter']
    tech_commission: Union[None, _int, 'types.IntFilter']
    company_cut: Union[None, _int, 'types.IntFilter']
    stripe_payment_intent_id: Union[None, _str, 'types.StringFilter']
    stripe_invoice_id: Union[None, _str, 'types.StringFilter']
    stripe_status: Union[None, _str, 'types.StringFilter']
    audited_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    audit_notes: Union[None, _str, 'types.StringFilter']
    audited_by_id: Union[None, _str, 'types.StringFilter']
    audited_by: 'AssociateRelationFilter'
    client_id: Union[_str, 'types.StringFilter']
    client: 'ClientRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'

    # should be noted that AND and NOT should be Union['OrderWhereInputRecursive3', List['OrderWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInputRecursive3']
    OR: List['OrderWhereInputRecursive3']
    NOT: List['OrderWhereInputRecursive3']


class OrderWhereInputRecursive3(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    invoice_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    sales_tax: Union[_int, 'types.IntFilter']
    total_due: Union[_int, 'types.IntFilter']
    transaction_fee: Union[_int, 'types.IntFilter']
    revenue: Union[_int, 'types.IntFilter']
    sales_commission: Union[None, _int, 'types.IntFilter']
    tech_commission: Union[None, _int, 'types.IntFilter']
    company_cut: Union[None, _int, 'types.IntFilter']
    stripe_payment_intent_id: Union[None, _str, 'types.StringFilter']
    stripe_invoice_id: Union[None, _str, 'types.StringFilter']
    stripe_status: Union[None, _str, 'types.StringFilter']
    audited_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    audit_notes: Union[None, _str, 'types.StringFilter']
    audited_by_id: Union[None, _str, 'types.StringFilter']
    audited_by: 'AssociateRelationFilter'
    client_id: Union[_str, 'types.StringFilter']
    client: 'ClientRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'

    # should be noted that AND and NOT should be Union['OrderWhereInputRecursive4', List['OrderWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInputRecursive4']
    OR: List['OrderWhereInputRecursive4']
    NOT: List['OrderWhereInputRecursive4']


class OrderWhereInputRecursive4(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    invoice_number: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    sales_tax: Union[_int, 'types.IntFilter']
    total_due: Union[_int, 'types.IntFilter']
    transaction_fee: Union[_int, 'types.IntFilter']
    revenue: Union[_int, 'types.IntFilter']
    sales_commission: Union[None, _int, 'types.IntFilter']
    tech_commission: Union[None, _int, 'types.IntFilter']
    company_cut: Union[None, _int, 'types.IntFilter']
    stripe_payment_intent_id: Union[None, _str, 'types.StringFilter']
    stripe_invoice_id: Union[None, _str, 'types.StringFilter']
    stripe_status: Union[None, _str, 'types.StringFilter']
    audited_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    audit_notes: Union[None, _str, 'types.StringFilter']
    audited_by_id: Union[None, _str, 'types.StringFilter']
    audited_by: 'AssociateRelationFilter'
    client_id: Union[_str, 'types.StringFilter']
    client: 'ClientRelationFilter'
    sales_associate_ids: 'types.StringListFilter'
    sales_associates: 'AssociateListRelationFilter'
    tech_associate_ids: 'types.StringListFilter'
    tech_associates: 'AssociateListRelationFilter'
    lineitem_ids: 'types.StringListFilter'
    lineitems: 'LineItemListRelationFilter'



# aggregate Order types


    

class OrderScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    invoice_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    sales_tax: Union[_int, 'types.IntWithAggregatesFilter']
    total_due: Union[_int, 'types.IntWithAggregatesFilter']
    transaction_fee: Union[_int, 'types.IntWithAggregatesFilter']
    revenue: Union[_int, 'types.IntWithAggregatesFilter']
    sales_commission: Union[_int, 'types.IntWithAggregatesFilter']
    tech_commission: Union[_int, 'types.IntWithAggregatesFilter']
    company_cut: Union[_int, 'types.IntWithAggregatesFilter']
    stripe_payment_intent_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_invoice_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_status: Union[_str, 'types.StringWithAggregatesFilter']
    audited_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    audit_notes: Union[_str, 'types.StringWithAggregatesFilter']
    audited_by_id: Union[_str, 'types.StringWithAggregatesFilter']
    client_id: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInputRecursive1']
    OR: List['OrderScalarWhereWithAggregatesInputRecursive1']
    NOT: List['OrderScalarWhereWithAggregatesInputRecursive1']


class OrderScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    invoice_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    sales_tax: Union[_int, 'types.IntWithAggregatesFilter']
    total_due: Union[_int, 'types.IntWithAggregatesFilter']
    transaction_fee: Union[_int, 'types.IntWithAggregatesFilter']
    revenue: Union[_int, 'types.IntWithAggregatesFilter']
    sales_commission: Union[_int, 'types.IntWithAggregatesFilter']
    tech_commission: Union[_int, 'types.IntWithAggregatesFilter']
    company_cut: Union[_int, 'types.IntWithAggregatesFilter']
    stripe_payment_intent_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_invoice_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_status: Union[_str, 'types.StringWithAggregatesFilter']
    audited_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    audit_notes: Union[_str, 'types.StringWithAggregatesFilter']
    audited_by_id: Union[_str, 'types.StringWithAggregatesFilter']
    client_id: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInputRecursive2']
    OR: List['OrderScalarWhereWithAggregatesInputRecursive2']
    NOT: List['OrderScalarWhereWithAggregatesInputRecursive2']


class OrderScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    invoice_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    sales_tax: Union[_int, 'types.IntWithAggregatesFilter']
    total_due: Union[_int, 'types.IntWithAggregatesFilter']
    transaction_fee: Union[_int, 'types.IntWithAggregatesFilter']
    revenue: Union[_int, 'types.IntWithAggregatesFilter']
    sales_commission: Union[_int, 'types.IntWithAggregatesFilter']
    tech_commission: Union[_int, 'types.IntWithAggregatesFilter']
    company_cut: Union[_int, 'types.IntWithAggregatesFilter']
    stripe_payment_intent_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_invoice_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_status: Union[_str, 'types.StringWithAggregatesFilter']
    audited_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    audit_notes: Union[_str, 'types.StringWithAggregatesFilter']
    audited_by_id: Union[_str, 'types.StringWithAggregatesFilter']
    client_id: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInputRecursive3']
    OR: List['OrderScalarWhereWithAggregatesInputRecursive3']
    NOT: List['OrderScalarWhereWithAggregatesInputRecursive3']


class OrderScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    invoice_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    sales_tax: Union[_int, 'types.IntWithAggregatesFilter']
    total_due: Union[_int, 'types.IntWithAggregatesFilter']
    transaction_fee: Union[_int, 'types.IntWithAggregatesFilter']
    revenue: Union[_int, 'types.IntWithAggregatesFilter']
    sales_commission: Union[_int, 'types.IntWithAggregatesFilter']
    tech_commission: Union[_int, 'types.IntWithAggregatesFilter']
    company_cut: Union[_int, 'types.IntWithAggregatesFilter']
    stripe_payment_intent_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_invoice_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_status: Union[_str, 'types.StringWithAggregatesFilter']
    audited_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    audit_notes: Union[_str, 'types.StringWithAggregatesFilter']
    audited_by_id: Union[_str, 'types.StringWithAggregatesFilter']
    client_id: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInputRecursive4']
    OR: List['OrderScalarWhereWithAggregatesInputRecursive4']
    NOT: List['OrderScalarWhereWithAggregatesInputRecursive4']


class OrderScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    invoice_number: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    sales_tax: Union[_int, 'types.IntWithAggregatesFilter']
    total_due: Union[_int, 'types.IntWithAggregatesFilter']
    transaction_fee: Union[_int, 'types.IntWithAggregatesFilter']
    revenue: Union[_int, 'types.IntWithAggregatesFilter']
    sales_commission: Union[_int, 'types.IntWithAggregatesFilter']
    tech_commission: Union[_int, 'types.IntWithAggregatesFilter']
    company_cut: Union[_int, 'types.IntWithAggregatesFilter']
    stripe_payment_intent_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_invoice_id: Union[_str, 'types.StringWithAggregatesFilter']
    stripe_status: Union[_str, 'types.StringWithAggregatesFilter']
    audited_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    audit_notes: Union[_str, 'types.StringWithAggregatesFilter']
    audited_by_id: Union[_str, 'types.StringWithAggregatesFilter']
    client_id: Union[_str, 'types.StringWithAggregatesFilter']
    sales_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    tech_associate_ids: Union[_str, 'types.StringWithAggregatesFilter']
    lineitem_ids: Union[_str, 'types.StringWithAggregatesFilter']



class OrderGroupByOutput(TypedDict, total=False):
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    invoice_number: _str
    status: _str
    sales_tax: _int
    total_due: _int
    transaction_fee: _int
    revenue: _int
    sales_commission: _int
    tech_commission: _int
    company_cut: _int
    stripe_payment_intent_id: _str
    stripe_invoice_id: _str
    stripe_status: _str
    audited_at: datetime.datetime
    audit_notes: _str
    audited_by_id: _str
    client_id: _str
    sales_associate_ids: List[_str]
    tech_associate_ids: List[_str]
    lineitem_ids: List[_str]
    _sum: 'OrderSumAggregateOutput'
    _avg: 'OrderAvgAggregateOutput'
    _min: 'OrderMinAggregateOutput'
    _max: 'OrderMaxAggregateOutput'
    _count: 'OrderCountAggregateOutput'


class OrderAvgAggregateOutput(TypedDict, total=False):
    """Order output for aggregating averages"""
    sales_tax: float
    total_due: float
    transaction_fee: float
    revenue: float
    sales_commission: float
    tech_commission: float
    company_cut: float


class OrderSumAggregateOutput(TypedDict, total=False):
    """Order output for aggregating sums"""
    sales_tax: _int
    total_due: _int
    transaction_fee: _int
    revenue: _int
    sales_commission: _int
    tech_commission: _int
    company_cut: _int


class OrderScalarAggregateOutput(TypedDict, total=False):
    """Order output including scalar fields"""
    id: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    invoice_number: _str
    status: _str
    sales_tax: _int
    total_due: _int
    transaction_fee: _int
    revenue: _int
    sales_commission: _int
    tech_commission: _int
    company_cut: _int
    stripe_payment_intent_id: _str
    stripe_invoice_id: _str
    stripe_status: _str
    audited_at: datetime.datetime
    audit_notes: _str
    audited_by_id: _str
    client_id: _str
    sales_associate_ids: List[_str]
    tech_associate_ids: List[_str]
    lineitem_ids: List[_str]


OrderMinAggregateOutput = OrderScalarAggregateOutput
OrderMaxAggregateOutput = OrderScalarAggregateOutput


class OrderMaxAggregateInput(TypedDict, total=False):
    """Order input for aggregating by max"""
    id: bool
    created_at: bool
    updated_at: bool
    invoice_number: bool
    status: bool
    sales_tax: bool
    total_due: bool
    transaction_fee: bool
    revenue: bool
    sales_commission: bool
    tech_commission: bool
    company_cut: bool
    stripe_payment_intent_id: bool
    stripe_invoice_id: bool
    stripe_status: bool
    audited_at: bool
    audit_notes: bool
    audited_by_id: bool
    client_id: bool
    sales_associate_ids: bool
    tech_associate_ids: bool
    lineitem_ids: bool


class OrderMinAggregateInput(TypedDict, total=False):
    """Order input for aggregating by min"""
    id: bool
    created_at: bool
    updated_at: bool
    invoice_number: bool
    status: bool
    sales_tax: bool
    total_due: bool
    transaction_fee: bool
    revenue: bool
    sales_commission: bool
    tech_commission: bool
    company_cut: bool
    stripe_payment_intent_id: bool
    stripe_invoice_id: bool
    stripe_status: bool
    audited_at: bool
    audit_notes: bool
    audited_by_id: bool
    client_id: bool
    sales_associate_ids: bool
    tech_associate_ids: bool
    lineitem_ids: bool


class OrderNumberAggregateInput(TypedDict, total=False):
    """Order input for aggregating numbers"""
    sales_tax: bool
    total_due: bool
    transaction_fee: bool
    revenue: bool
    sales_commission: bool
    tech_commission: bool
    company_cut: bool


OrderAvgAggregateInput = OrderNumberAggregateInput
OrderSumAggregateInput = OrderNumberAggregateInput


OrderCountAggregateInput = TypedDict(
    'OrderCountAggregateInput',
    {
        'id': bool,
        'created_at': bool,
        'updated_at': bool,
        'invoice_number': bool,
        'status': bool,
        'sales_tax': bool,
        'total_due': bool,
        'transaction_fee': bool,
        'revenue': bool,
        'sales_commission': bool,
        'tech_commission': bool,
        'company_cut': bool,
        'stripe_payment_intent_id': bool,
        'stripe_invoice_id': bool,
        'stripe_status': bool,
        'audited_at': bool,
        'audit_notes': bool,
        'audited_by_id': bool,
        'client_id': bool,
        'sales_associate_ids': bool,
        'tech_associate_ids': bool,
        'lineitem_ids': bool,
        '_all': bool,
    },
    total=False,
)

OrderCountAggregateOutput = TypedDict(
    'OrderCountAggregateOutput',
    {
        'id': int,
        'created_at': int,
        'updated_at': int,
        'invoice_number': int,
        'status': int,
        'sales_tax': int,
        'total_due': int,
        'transaction_fee': int,
        'revenue': int,
        'sales_commission': int,
        'tech_commission': int,
        'company_cut': int,
        'stripe_payment_intent_id': int,
        'stripe_invoice_id': int,
        'stripe_status': int,
        'audited_at': int,
        'audit_notes': int,
        'audited_by_id': int,
        'client_id': int,
        'sales_associate_ids': int,
        'tech_associate_ids': int,
        'lineitem_ids': int,
        '_all': int,
    },
    total=False,
)


OrderKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'invoice_number',
    'status',
    'sales_tax',
    'total_due',
    'transaction_fee',
    'revenue',
    'sales_commission',
    'tech_commission',
    'company_cut',
    'stripe_payment_intent_id',
    'stripe_invoice_id',
    'stripe_status',
    'audited_at',
    'audit_notes',
    'audited_by_id',
    'audited_by',
    'client_id',
    'client',
    'sales_associate_ids',
    'sales_associates',
    'tech_associate_ids',
    'tech_associates',
    'lineitem_ids',
    'lineitems',
]
OrderScalarFieldKeys = Literal[
    'id',
    'created_at',
    'updated_at',
    'invoice_number',
    'status',
    'sales_tax',
    'total_due',
    'transaction_fee',
    'revenue',
    'sales_commission',
    'tech_commission',
    'company_cut',
    'stripe_payment_intent_id',
    'stripe_invoice_id',
    'stripe_status',
    'audited_at',
    'audit_notes',
    'audited_by_id',
    'client_id',
    'sales_associate_ids',
    'tech_associate_ids',
    'lineitem_ids',
]
OrderScalarFieldKeysT = TypeVar('OrderScalarFieldKeysT', bound=OrderScalarFieldKeys)

OrderRelationalFieldKeys = Literal[
        'audited_by',
        'client',
        'sales_associates',
        'tech_associates',
        'lineitems',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields